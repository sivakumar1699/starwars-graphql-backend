"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Neo4jGraphQLSubscriptionsCDCEngine = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const events_1 = require("events");
const typescript_memoize_1 = require("typescript-memoize");
const constants_1 = require("../../constants");
const cdc_api_1 = require("./cdc/cdc-api");
const cdc_event_parser_1 = require("./cdc/cdc-event-parser");
class Neo4jGraphQLSubscriptionsCDCEngine {
    constructor({ driver, pollTime = 1000, queryConfig, onlyGraphQLEvents = false, }) {
        this.events = new events_1.EventEmitter();
        this.closed = false;
        this.cdcApi = new cdc_api_1.CDCApi(driver, queryConfig);
        this.pollTime = pollTime;
        this.onlyGraphQLEvents = onlyGraphQLEvents;
    }
    // This memoize is done to keep typings correct whilst avoiding the performance ir of the throw
    get parser() {
        if (!this._parser)
            throw new Error("CDC Event parser not available on SubscriptionEngine. Forgot to call .init on SubscriptionEngine?");
        return this._parser;
    }
    async init({ schemaModel }) {
        await this.cdcApi.updateCursor();
        this._parser = new cdc_event_parser_1.CDCEventParser(schemaModel);
        this.subscribeToLabels = this.getLabelsToFilter(schemaModel);
        schemaModel.concreteEntities.map((e) => Array.from(e.labels));
        this.triggerPoll();
    }
    /** Stops CDC polling */
    close() {
        this.closed = true;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
    }
    triggerPoll() {
        this.timer = setTimeout(() => {
            if (this.closed) {
                return;
            }
            this.pollEvents()
                .catch((err) => {
                console.error(err);
            })
                .finally(() => {
                this.triggerPoll();
            });
        }, this.pollTime);
    }
    async pollEvents() {
        let txFilter;
        if (this.onlyGraphQLEvents) {
            const appMetadata = new cypher_builder_1.default.Param(constants_1.APP_ID);
            txFilter = new cypher_builder_1.default.Map({
                app: appMetadata,
            });
        }
        const cdcEvents = await this.cdcApi.queryEvents(this.subscribeToLabels, txFilter);
        for (const cdcEvent of cdcEvents) {
            const parsedEvent = this.parser.parseCDCEvent(cdcEvent);
            if (parsedEvent) {
                this.events.emit(parsedEvent.event, parsedEvent);
            }
        }
    }
    getLabelsToFilter(schemaModel) {
        const uniqueLabels = new Set(schemaModel.concreteEntities.flatMap((e) => Array.from(e.labels)));
        return Array.from(uniqueLabels);
    }
}
exports.Neo4jGraphQLSubscriptionsCDCEngine = Neo4jGraphQLSubscriptionsCDCEngine;
__decorate([
    (0, typescript_memoize_1.Memoize)()
], Neo4jGraphQLSubscriptionsCDCEngine.prototype, "parser", null);
//# sourceMappingURL=Neo4jGraphQLSubscriptionsCDCEngine.js.map