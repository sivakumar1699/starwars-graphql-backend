"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthFilterFactory = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const get_entity_adapter_1 = require("../../../schema-model/utils/get-entity-adapter");
const utils_1 = require("../../../utils/utils");
const logical_operators_1 = require("../../utils/logical-operators");
const Filter_1 = require("../ast/filters/Filter");
const LogicalFilter_1 = require("../ast/filters/LogicalFilter");
const AuthConnectionFilter_1 = require("../ast/filters/authorization-filters/AuthConnectionFilter");
const AuthRelationshipFilter_1 = require("../ast/filters/authorization-filters/AuthRelationshipFilter");
const JWTFilter_1 = require("../ast/filters/authorization-filters/JWTFilter");
const CypherFilter_1 = require("../ast/filters/property-filters/CypherFilter");
const ParamPropertyFilter_1 = require("../ast/filters/property-filters/ParamPropertyFilter");
const PropertyFilter_1 = require("../ast/filters/property-filters/PropertyFilter");
const CustomCypherSelection_1 = require("../ast/selection/CustomCypherSelection");
const FilterFactory_1 = require("./FilterFactory");
const parse_where_field_1 = require("./parsers/parse-where-field");
class AuthFilterFactory extends FilterFactory_1.FilterFactory {
    // PopulatedWhere has the values as Cypher variables
    createAuthFilters({ entity, operations, context, populatedWhere, }) {
        return Object.entries(populatedWhere).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = value.flatMap((v) => {
                    return this.createAuthFilters({
                        entity,
                        operations,
                        context,
                        populatedWhere: v,
                    });
                });
                return [
                    new LogicalFilter_1.LogicalFilter({
                        operation: key,
                        filters: nestedFilters,
                    }),
                ];
            }
            if (key === "node") {
                return this.createNodeFilters(entity, value);
            }
            else if (key === "jwt") {
                return this.createJWTFilters(context.authorization.jwtParam, value, context);
            }
            return [];
        });
    }
    createJWTFilters(jwtPayload, where, context) {
        return Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = (0, utils_1.asArray)(value).flatMap((v) => {
                    return this.createJWTFilters(jwtPayload, v, context);
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
            }
            const { fieldName, operator } = (0, parse_where_field_1.parseWhereField)(key);
            if (!fieldName) {
                throw new Error(`Failed to find field name in filter: ${key}`);
            }
            const mappedJwtClaim = context.authorization.claims?.get(fieldName);
            let target = jwtPayload.property(fieldName);
            if (mappedJwtClaim) {
                // TODO: validate browser compatibility for Toolbox (https://caniuse.com/?search=Lookbehind)
                let paths = mappedJwtClaim.split(/(?<!\\)\./);
                paths = paths.map((p) => p.replaceAll(/\\\./g, "."));
                target = jwtPayload.property(...paths);
            }
            if (!operator) {
                return this.wrapMultipleFiltersInLogical(this.getGenericJWTFilters(value, target));
            }
            return new JWTFilter_1.JWTFilter({
                operator: operator,
                JWTClaim: target,
                comparisonValue: value,
            });
        });
    }
    getGenericJWTFilters(genericOperator, target) {
        return Object.entries(genericOperator).map(([key, value]) => {
            const operator = this.parseGenericOperator(key);
            return new JWTFilter_1.JWTFilter({
                operator,
                JWTClaim: target,
                comparisonValue: value,
            });
        });
    }
    createPropertyFilter({ attribute, comparisonValue, operator, attachedTo, relationship, }) {
        const isCypherVariable = comparisonValue instanceof cypher_builder_1.default.Variable ||
            comparisonValue instanceof cypher_builder_1.default.Property ||
            comparisonValue instanceof cypher_builder_1.default.Param;
        if (attribute.annotations.cypher) {
            const selection = new CustomCypherSelection_1.CustomCypherSelection({
                operationField: attribute,
                rawArguments: {},
                isNested: true,
            });
            if (attribute.annotations.cypher?.targetEntity) {
                const entityAdapter = (0, get_entity_adapter_1.getEntityAdapter)(attribute.annotations.cypher.targetEntity);
                if (operator && !(0, Filter_1.isLegacyRelationshipOperator)(operator)) {
                    throw new Error(`Invalid operator ${operator} for relationship`);
                }
                // path for generic filters input, in v8 it will be the only path
                if (!operator && attribute.typeHelper.isList()) {
                    const genericFilters = Object.entries(comparisonValue).flatMap(([quantifier, predicate]) => {
                        const legacyOperator = this.convertRelationshipOperatorToLegacyOperator(quantifier);
                        return this.createCypherRelationshipFilter({
                            where: predicate,
                            selection,
                            target: entityAdapter,
                            operator: legacyOperator,
                            attribute,
                        });
                    });
                    return new LogicalFilter_1.LogicalFilter({
                        operation: "AND",
                        filters: genericFilters,
                    });
                }
                return new LogicalFilter_1.LogicalFilter({
                    operation: "AND",
                    filters: this.createCypherRelationshipFilter({
                        where: comparisonValue,
                        selection,
                        target: entityAdapter,
                        operator,
                        attribute,
                    }),
                });
            }
            if (isCypherVariable) {
                return new CypherFilter_1.CypherFilter({
                    selection,
                    attribute,
                    comparisonValue: comparisonValue,
                    operator: operator ?? "EQ",
                    checkIsNotNull: true,
                });
            }
            const comparisonValueParam = new cypher_builder_1.default.Param(comparisonValue);
            return new CypherFilter_1.CypherFilter({
                selection,
                attribute,
                comparisonValue: comparisonValueParam,
                operator: operator ?? "EQ",
            });
        }
        if (!operator) {
            throw new Error(`Operator is required for property filter`);
        }
        // This is probably not needed, but avoid changing the cypher
        if (typeof comparisonValue === "boolean") {
            return new ParamPropertyFilter_1.ParamPropertyFilter({
                attribute,
                relationship,
                comparisonValue: new cypher_builder_1.default.Param(comparisonValue),
                operator,
                attachedTo,
            });
        }
        if (isCypherVariable) {
            return new ParamPropertyFilter_1.ParamPropertyFilter({
                attribute,
                relationship,
                comparisonValue: comparisonValue,
                operator,
                attachedTo,
            });
        }
        else {
            if (comparisonValue === null) {
                return new PropertyFilter_1.PropertyFilter({
                    attribute,
                    relationship,
                    comparisonValue: comparisonValue,
                    operator,
                    attachedTo,
                });
            }
            return new ParamPropertyFilter_1.ParamPropertyFilter({
                attribute,
                relationship,
                comparisonValue: new cypher_builder_1.default.Param(comparisonValue),
                operator,
                attachedTo,
            });
        }
    }
    createRelationshipFilterTreeNode(options) {
        return new AuthRelationshipFilter_1.AuthRelationshipFilter(options);
    }
    createConnectionFilterTreeNode(options) {
        return new AuthConnectionFilter_1.AuthConnectionFilter(options);
    }
}
exports.AuthFilterFactory = AuthFilterFactory;
//# sourceMappingURL=AuthFilterFactory.js.map