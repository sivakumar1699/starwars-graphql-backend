"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterFactory = void 0;
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const get_entity_adapter_1 = require("../../../schema-model/utils/get-entity-adapter");
const global_ids_1 = require("../../../utils/global-ids");
const utils_1 = require("../../../utils/utils");
const logical_operators_1 = require("../../utils/logical-operators");
const ConnectionFilter_1 = require("../ast/filters/ConnectionFilter");
const CypherOneToOneRelationshipFilter_1 = require("../ast/filters/CypherOneToOneRelationshipFilter");
const CypherRelationshipFilter_1 = require("../ast/filters/CypherRelationshipFilter");
const Filter_1 = require("../ast/filters/Filter");
const LogicalFilter_1 = require("../ast/filters/LogicalFilter");
const RelationshipFilter_1 = require("../ast/filters/RelationshipFilter");
const AggregationDateTimePropertyFilter_1 = require("../ast/filters/aggregation/AggregationDateTimePropertyFilter");
const AggregationDurationPropertyFilter_1 = require("../ast/filters/aggregation/AggregationDurationPropertyFilter");
const AggregationPropertyFilter_1 = require("../ast/filters/aggregation/AggregationPropertyFilter");
const AggregationTimePropertyFilter_1 = require("../ast/filters/aggregation/AggregationTimePropertyFilter");
const CountFilter_1 = require("../ast/filters/aggregation/CountFilter");
const CypherFilter_1 = require("../ast/filters/property-filters/CypherFilter");
const DateTimeFilter_1 = require("../ast/filters/property-filters/DateTimeFilter");
const DurationFilter_1 = require("../ast/filters/property-filters/DurationFilter");
const PointFilter_1 = require("../ast/filters/property-filters/PointFilter");
const PropertyFilter_1 = require("../ast/filters/property-filters/PropertyFilter");
const TimeFilter_1 = require("../ast/filters/property-filters/TimeFilter");
const TypenameFilter_1 = require("../ast/filters/property-filters/TypenameFilter");
const CustomCypherSelection_1 = require("../ast/selection/CustomCypherSelection");
const get_concrete_entities_1 = require("../utils/get-concrete-entities");
const is_concrete_entity_1 = require("../utils/is-concrete-entity");
const is_interface_entity_1 = require("../utils/is-interface-entity");
const is_relationship_entity_1 = require("../utils/is-relationship-entity");
const is_union_entity_1 = require("../utils/is-union-entity");
const parse_where_field_1 = require("./parsers/parse-where-field");
class FilterFactory {
    constructor(queryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }
    createConnectionFilter(relationship, where, operator) {
        if ((0, is_interface_entity_1.isInterfaceEntity)(relationship.target) &&
            this.isLabelOptimizationForInterfacePossible(where, relationship.target)) {
            const connectionFilter = this.createConnectionFilterTreeNode({
                relationship: relationship,
                target: relationship.target,
                operator,
            });
            const filters = this.createConnectionPredicates({ rel: relationship, entity: relationship.target, where });
            connectionFilter.addFilters(filters);
            return (0, utils_1.asArray)(connectionFilter);
        }
        const filteredEntities = (0, get_concrete_entities_1.getConcreteEntities)(relationship.target, where);
        const connectionFilters = [];
        let partialOf;
        if ((0, is_interface_entity_1.isInterfaceEntity)(relationship.target)) {
            partialOf = relationship.target;
        }
        for (const concreteEntity of filteredEntities) {
            const connectionFilter = this.createConnectionFilterTreeNode({
                relationship: relationship,
                target: concreteEntity,
                operator,
            });
            const filters = this.createConnectionPredicates({
                rel: relationship,
                entity: concreteEntity,
                where,
                partialOf,
            });
            connectionFilter.addFilters(filters);
            connectionFilters.push(connectionFilter);
        }
        const logicalOp = this.getLogicalOperatorForRelatedNodeFilters(relationship.target, operator);
        return this.wrapMultipleFiltersInLogical(connectionFilters, logicalOp);
    }
    createConnectionPredicates({ rel, entity, where, partialOf, }) {
        let entityWhere = where;
        if (rel && (0, is_union_entity_1.isUnionEntity)(rel.target) && where[entity.name]) {
            entityWhere = where[entity.name];
        }
        const filters = (0, utils_1.asArray)(entityWhere).flatMap((nestedWhere) => {
            return Object.entries(nestedWhere).flatMap(([key, value]) => {
                if ((0, logical_operators_1.isLogicalOperator)(key)) {
                    const nestedFilters = this.createConnectionPredicates({ rel, entity, where: value, partialOf });
                    return [
                        new LogicalFilter_1.LogicalFilter({
                            operation: key,
                            filters: (0, utils_1.filterTruthy)(nestedFilters),
                        }),
                    ];
                }
                if (rel && key === "edge") {
                    return this.createEdgeFilters(rel, value);
                }
                if (key === "node") {
                    if (partialOf && (0, is_interface_entity_1.isInterfaceEntity)(partialOf) && (0, is_concrete_entity_1.isConcreteEntity)(entity)) {
                        return this.createInterfaceNodeFilters({
                            entity: partialOf,
                            targetEntity: entity,
                            whereFields: value,
                        });
                    }
                    else if ((0, is_interface_entity_1.isInterfaceEntity)(entity)) {
                        return this.createInterfaceNodeFilters({
                            entity,
                            whereFields: value,
                            relationship: rel,
                        });
                    }
                    return this.createNodeFilters(entity, value);
                }
            });
        });
        return (0, utils_1.filterTruthy)(filters);
    }
    createCypherFilter({ attribute, comparisonValue, operator, }) {
        const selection = new CustomCypherSelection_1.CustomCypherSelection({
            operationField: attribute,
            rawArguments: {},
            isNested: true,
        });
        if (attribute.annotations.cypher?.targetEntity) {
            const entityAdapter = (0, get_entity_adapter_1.getEntityAdapter)(attribute.annotations.cypher.targetEntity);
            if (operator && !(0, Filter_1.isLegacyRelationshipOperator)(operator)) {
                throw new Error(`Invalid operator ${operator} for relationship`);
            }
            // path for generic filters input, in v8 it will be the only path
            if (!operator && attribute.typeHelper.isList()) {
                const genericFilters = Object.entries(comparisonValue).flatMap(([quantifier, predicate]) => {
                    const legacyOperator = this.convertRelationshipOperatorToLegacyOperator(quantifier);
                    return this.createCypherRelationshipFilter({
                        where: predicate,
                        selection,
                        target: entityAdapter,
                        operator: legacyOperator,
                        attribute,
                    });
                });
                return this.wrapMultipleFiltersInLogical(genericFilters);
            }
            return this.createCypherRelationshipFilter({
                where: comparisonValue,
                selection,
                target: entityAdapter,
                operator: operator ?? "SOME",
                attribute,
            });
        }
        const comparisonValueParam = new cypher_builder_1.default.Param(comparisonValue);
        return new CypherFilter_1.CypherFilter({
            selection,
            attribute,
            comparisonValue: comparisonValueParam,
            operator: operator ?? "EQ",
        });
    }
    createPropertyFilter({ attribute, relationship, comparisonValue, operator, attachedTo, }) {
        if (attribute.annotations.cypher) {
            return this.createCypherFilter({
                attribute,
                comparisonValue,
                operator,
            });
        }
        // Implicit _EQ filters are removed but the argument "operator" can still be undefined in some cases, for instance:
        // Cypher 1:1 relationship filters as they are stored as Attribute.
        // Federation Subgraph resolver, _entities field implementation is using the FilterFactory {  "__typename": "Product",  "upc": "abc123"}.
        operator = operator ?? "EQ";
        if (attribute.typeHelper.isDuration()) {
            return new DurationFilter_1.DurationFilter({
                attribute,
                comparisonValue,
                operator,
                attachedTo,
            });
        }
        if (attribute.typeHelper.isPoint() || attribute.typeHelper.isCartesianPoint()) {
            return new PointFilter_1.PointFilter({
                attribute,
                comparisonValue,
                operator,
                attachedTo,
            });
        }
        if (attribute.typeHelper.isDateTime()) {
            return new DateTimeFilter_1.DateTimeFilter({
                attribute,
                comparisonValue,
                operator,
                attachedTo,
            });
        }
        if (attribute.typeHelper.isTime()) {
            return new TimeFilter_1.TimeFilter({
                attribute,
                comparisonValue,
                operator,
                attachedTo,
            });
        }
        return new PropertyFilter_1.PropertyFilter({
            attribute,
            relationship,
            comparisonValue,
            operator,
            attachedTo,
        });
    }
    createRelationshipFilter(relationship, where, operator) {
        /**
         * The logic below can be confusing, but it's to handle the following cases:
         * 1. where: { actors: null } -> in this case we want to return an Exists filter as showed by tests packages/graphql/tests/tck/null.test.ts
         * 2. where: {} -> in this case we want to not apply any filter, as showed by tests packages/graphql/tests/tck/issues/402.test.ts
         **/
        const isNull = where === null;
        if (!isNull && Object.keys(where).length === 0) {
            return [];
        }
        const filteredEntities = (0, get_concrete_entities_1.getConcreteEntities)(relationship.target, where);
        const relationshipFilters = [];
        for (const concreteEntity of filteredEntities) {
            const relationshipFilter = this.createRelationshipFilterTreeNode({
                relationship,
                target: concreteEntity,
                operator: operator ?? "SOME",
            });
            if (!isNull) {
                const entityWhere = where[concreteEntity.name] ?? where;
                const targetNodeFilters = this.createNodeFilters(concreteEntity, entityWhere);
                relationshipFilter.addTargetNodeFilter(...targetNodeFilters);
            }
            relationshipFilters.push(relationshipFilter);
        }
        const logicalOp = this.getLogicalOperatorForRelatedNodeFilters(relationship.target, operator);
        return this.wrapMultipleFiltersInLogical(relationshipFilters, logicalOp);
    }
    createCypherRelationshipFilter({ selection, target, where, attribute, operator, }) {
        /**
         * The logic below can be confusing, but it's to handle the following cases:
         * 1. where: { actors: null } -> in this case we want to return an Exists filter as showed by tests packages/graphql/tests/tck/null.test.ts
         * 2. where: {} -> in this case we want to not apply any filter, as showed by tests packages/graphql/tests/tck/issues/402.test.ts
         **/
        const isNull = where === null;
        if (!isNull && Object.keys(where).length === 0) {
            return [];
        }
        // TODO the below logic is unnecessary, Cypher relationship are not supported for Composite Entities
        const filteredEntities = (0, get_concrete_entities_1.getConcreteEntities)(target, where);
        const filters = [];
        for (const concreteEntity of filteredEntities) {
            const returnVariable = new cypher_builder_1.default.Node();
            const options = {
                selection,
                isNull,
                operator: operator ?? "SOME",
                attribute,
                returnVariable,
            };
            const filter = attribute.typeHelper.isList()
                ? this.createCypherRelationshipFilterTreeNode(options)
                : this.createCypherOneToOneRelationshipFilterTreeNode(options);
            if (!isNull) {
                const entityWhere = where[concreteEntity.name] ?? where;
                const targetNodeFilters = this.createNodeFilters(concreteEntity, entityWhere);
                filter.addTargetNodeFilter(...targetNodeFilters);
            }
            filters.push(filter);
        }
        const logicalOp = this.getLogicalOperatorForRelatedNodeFilters(target, operator);
        return this.wrapMultipleFiltersInLogical(filters, logicalOp);
    }
    // This allows to override this creation in AuthFilterFactory
    createCypherOneToOneRelationshipFilterTreeNode(options) {
        return new CypherOneToOneRelationshipFilter_1.CypherOneToOneRelationshipFilter(options);
    }
    // This allows to override this creation in AuthFilterFactory
    createCypherRelationshipFilterTreeNode(options) {
        return new CypherRelationshipFilter_1.CypherRelationshipFilter(options);
    }
    // This allows to override this creation in AuthFilterFactory
    createRelationshipFilterTreeNode(options) {
        return new RelationshipFilter_1.RelationshipFilter(options);
    }
    // This allows to override this creation in AuthFilterFactory
    createConnectionFilterTreeNode(options) {
        return new ConnectionFilter_1.ConnectionFilter(options);
    }
    createInterfaceNodeFilters({ entity, targetEntity, whereFields, relationship, }) {
        const filters = (0, utils_1.filterTruthy)(Object.entries(whereFields).flatMap(([key, value]) => {
            return this.parseEntryFilter({ entity, key, value, targetEntity, relationship });
        }));
        return this.wrapMultipleFiltersInLogical(filters);
    }
    createNodeFilters(entity, whereFields) {
        if ((0, is_union_entity_1.isUnionEntity)(entity)) {
            return [];
        }
        const filters = (0, utils_1.filterTruthy)(Object.entries(whereFields).flatMap(([key, value]) => {
            return this.parseEntryFilter({ entity, key, value });
        }));
        return this.wrapMultipleFiltersInLogical(filters);
    }
    parseEntryFilter({ entity, key, value, targetEntity, relationship, }) {
        const valueAsArray = (0, utils_1.asArray)(value);
        if ((0, logical_operators_1.isLogicalOperator)(key)) {
            const nestedFilters = valueAsArray.flatMap((nestedWhere) => {
                const nestedOfNestedFilters = Object.entries(nestedWhere).flatMap(([nestedKey, nestedValue]) => {
                    return (0, utils_1.asArray)(this.parseEntryFilter({
                        entity,
                        key: nestedKey,
                        value: nestedValue,
                        targetEntity,
                        relationship,
                    }));
                });
                return this.wrapMultipleFiltersInLogical(nestedOfNestedFilters);
            });
            return new LogicalFilter_1.LogicalFilter({
                operation: key,
                filters: nestedFilters,
            });
        }
        const { fieldName, operator, isConnection, isAggregate } = (0, parse_where_field_1.parseWhereField)(key);
        if ((0, is_concrete_entity_1.isConcreteEntity)(entity)) {
            const relationship = entity.findRelationship(fieldName);
            if (relationship) {
                return this.createRelatedNodeFilters({
                    relationship,
                    value,
                    operator,
                    isConnection,
                    isAggregate,
                });
            }
        }
        else {
            const relationshipDeclaration = entity.findRelationshipDeclarations(fieldName);
            if (targetEntity && relationshipDeclaration) {
                const relationship = relationshipDeclaration.relationshipImplementations.find((r) => r.source.name === targetEntity.name);
                if (!relationship) {
                    throw new Error(`Relationship ${fieldName} not found`);
                }
                return this.createRelatedNodeFilters({
                    relationship,
                    value,
                    operator,
                    isConnection,
                    isAggregate,
                });
            }
            if (key === "typename") {
                const acceptedEntities = entity.concreteEntities.filter((concreteEntity) => {
                    return valueAsArray.some((typenameFilterValue) => typenameFilterValue === concreteEntity.name);
                });
                return new TypenameFilter_1.TypenameFilter(acceptedEntities);
            }
        }
        const attribute = entity.findAttribute(fieldName);
        if (!(0, is_interface_entity_1.isInterfaceEntity)(entity) && !attribute) {
            if (fieldName === "id" && entity.globalIdField) {
                return this.createRelayIdPropertyFilter(entity, operator, value);
            }
        }
        if (!attribute) {
            throw new Error(`Attribute ${fieldName} not found`);
        }
        // This is a bit hacky, basically skipping cypher fields and federation strings being passed to filterFactory
        if (!operator && !attribute.annotations.cypher?.targetEntity && typeof value === "object") {
            return this.parseGenericFilters(entity, fieldName, value, relationship);
        }
        return this.createPropertyFilter({
            attribute,
            comparisonValue: value,
            operator: operator,
            relationship,
        });
    }
    parseGenericFilters(entity, fieldName, value, relationship) {
        const genericFilters = Object.entries(value).flatMap((filterInput) => {
            return this.parseGenericFilter(entity, fieldName, filterInput, relationship);
        });
        return this.wrapMultipleFiltersInLogical(genericFilters);
    }
    parseGenericFilter(entity, fieldName, filterInput, relationship) {
        const [rawOperator, value] = filterInput;
        if ((0, logical_operators_1.isLogicalOperator)(rawOperator)) {
            const nestedFilters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                return this.parseGenericFilter(entity, fieldName, nestedWhere, relationship);
            });
            return new LogicalFilter_1.LogicalFilter({
                operation: rawOperator,
                filters: nestedFilters,
            });
        }
        if (rawOperator === "distance") {
            // Converts new distance filter into the old one to be parsed the same as deprecated syntax
            const desugaredInput = this.desugarGenericDistanceOperations(value);
            return this.parseGenericFilters(entity, fieldName, desugaredInput, relationship);
        }
        const operator = this.parseGenericOperator(rawOperator);
        const attribute = entity.findAttribute(fieldName);
        if (!attribute) {
            if ((0, is_relationship_entity_1.isRelationshipEntity)(entity) || (0, is_interface_entity_1.isInterfaceEntity)(entity)) {
                throw new Error("Transpilation error: Expected concrete entity");
            }
            if (fieldName === "id" && entity.globalIdField) {
                return this.createRelayIdPropertyFilter(entity, operator, value);
            }
            throw new Error(`Attribute ${fieldName} not found`);
        }
        const attachedTo = (0, is_relationship_entity_1.isRelationshipEntity)(entity) ? "relationship" : "node";
        const filters = this.createPropertyFilter({
            attribute,
            comparisonValue: value,
            operator,
            attachedTo,
            relationship,
        });
        return this.wrapMultipleFiltersInLogical((0, utils_1.asArray)(filters));
    }
    parseGenericOperator(key) {
        // we convert them to the previous format to keep the same translation logic
        switch (key) {
            case "eq":
                return "EQ";
            case "in":
                return "IN";
            case "lt":
                return "LT";
            case "lte":
                return "LTE";
            case "greaterThan":
            case "gt":
                return "GT";
            case "gte":
                return "GTE";
            case "contains":
                return "CONTAINS";
            case "startsWith":
                return "STARTS_WITH";
            case "endsWith":
                return "ENDS_WITH";
            case "matches":
                return "MATCHES";
            case "includes":
                return "INCLUDES";
            case "distance_eq": // Used for distance -> eq
                return "DISTANCE";
            default:
                throw new Error(`Invalid operator ${key}`);
        }
    }
    parseGenericOperatorForAggregation(key) {
        // we convert them to the previous format to keep the same translation logic
        switch (key) {
            case "eq":
                return "EQUAL";
            case "lt":
                return "LT";
            case "lte":
                return "LTE";
            case "gt":
                return "GT";
            case "gte":
                return "GTE";
            default:
                throw new Error(`Invalid operator ${key}`);
        }
    }
    convertRelationshipOperatorToLegacyOperator(operator) {
        switch (operator) {
            case "some":
                return "SOME";
            case "all":
                return "ALL";
            case "single":
                return "SINGLE";
            case "none":
                return "NONE";
        }
        throw new Error(`Invalid operator ${operator}`);
    }
    createRelatedNodeFilters({ relationship, value, operator, isConnection, isAggregate, }) {
        if (isAggregate) {
            return this.createAggregationFilter({
                relationship,
                where: value,
                isDeprecated: true,
            });
        }
        if (!operator) {
            const genericFilters = Object.entries(value).flatMap(([genericOperator, predicate]) => {
                if (genericOperator === "aggregate") {
                    return this.createAggregationFilter({
                        relationship,
                        where: predicate,
                        isDeprecated: false,
                    });
                }
                const legacyOperator = this.convertRelationshipOperatorToLegacyOperator(genericOperator);
                return this.createRelatedNodeFilters({
                    relationship,
                    value: predicate,
                    operator: legacyOperator,
                    isConnection,
                    isAggregate,
                });
            });
            return this.wrapMultipleFiltersInLogical(genericFilters);
        }
        if (operator && !(0, Filter_1.isLegacyRelationshipOperator)(operator)) {
            throw new Error(`Invalid operator ${operator} for relationship`);
        }
        if (isConnection) {
            return this.createConnectionFilter(relationship, value, operator);
        }
        return this.createRelationshipFilter(relationship, value, operator);
    }
    getLogicalOperatorForRelatedNodeFilters(target, operator = "SOME") {
        if ((0, is_interface_entity_1.isInterfaceEntity)(target) || (0, is_union_entity_1.isUnionEntity)(target)) {
            if (operator === "SOME") {
                return "OR";
            }
            if (operator === "SINGLE") {
                return "XOR";
            }
        }
        return "AND";
    }
    createRelayIdPropertyFilter(entity, operator = "EQ", value) {
        const relayIdData = (0, global_ids_1.fromGlobalId)(value);
        const { typeName, field } = relayIdData;
        let id = relayIdData.id;
        if (typeName !== entity.name || !field || !id) {
            throw new Error(`Cannot query Relay Id on "${entity.name}"`);
        }
        const idAttribute = entity.findAttribute(field);
        if (!idAttribute) {
            throw new Error(`Attribute ${field} not found`);
        }
        if (idAttribute.typeHelper.isNumeric()) {
            id = Number(id);
            if (Number.isNaN(id)) {
                throw new Error("Can't parse non-numeric relay id");
            }
        }
        return this.createPropertyFilter({
            attribute: idAttribute,
            comparisonValue: id,
            operator,
        });
    }
    createEdgeFilters(relationship, where) {
        const filterASTs = Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                    return this.createEdgeFilters(relationship, nestedWhere);
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
            }
            const { fieldName, operator } = (0, parse_where_field_1.parseWhereField)(key);
            const attribute = relationship.findAttribute(fieldName);
            if (!attribute) {
                // @declareRelationship path.
                if (fieldName === relationship.propertiesTypeName) {
                    return this.createEdgeFilters(relationship, value);
                }
                return;
            }
            if (!operator) {
                return this.parseGenericFilters(relationship, fieldName, value);
            }
            return this.createPropertyFilter({
                attribute,
                comparisonValue: value,
                operator,
                attachedTo: "relationship",
            });
        });
        return this.wrapMultipleFiltersInLogical((0, utils_1.filterTruthy)(filterASTs));
    }
    createCountFilter({ operatorKey, value, attachedTo, useDeprecated = true, relationship, }) {
        const operator = this.parseGenericOperator(operatorKey);
        return new CountFilter_1.CountFilter({
            operator: operator,
            comparisonValue: value,
            attachedTo,
            relationship,
            isDeprecated: useDeprecated,
        });
    }
    parseConnectionAggregationCountFilter({ countInput, attachedTo, relationship, }) {
        return Object.entries(countInput).map(([key, value]) => {
            const operator = this.parseGenericOperator(key);
            return new CountFilter_1.CountFilter({
                operator: operator,
                comparisonValue: value,
                attachedTo,
                relationship,
                isDeprecated: false,
            });
        });
    }
    getAggregationNestedFilters({ where, relationship, isDeprecated, }) {
        const nestedFilters = Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                    return this.getAggregationNestedFilters({
                        where: nestedWhere,
                        relationship,
                        isDeprecated,
                    });
                });
                const logicalFilter = new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
                return [logicalFilter];
            }
            const { fieldName, logicalOperator: operator } = (0, parse_where_field_1.parseAggregationWhereFields)(key);
            if (fieldName === "count") {
                if (!operator) {
                    if (!isDeprecated) {
                        return Object.entries(value).flatMap(([key, value]) => {
                            if (key === "nodes") {
                                return this.parseConnectionAggregationCountFilter({
                                    countInput: value,
                                    attachedTo: "node",
                                    relationship,
                                });
                            }
                            return this.parseConnectionAggregationCountFilter({
                                countInput: value,
                                attachedTo: "relationship",
                                relationship,
                            });
                        });
                    }
                    return Object.entries(value).map(([key, value]) => {
                        const operator = this.parseGenericOperator(key);
                        return new CountFilter_1.CountFilter({
                            operator: operator,
                            comparisonValue: value,
                            attachedTo: "node",
                            relationship,
                            isDeprecated,
                        });
                    });
                }
                const countFilter = new CountFilter_1.CountFilter({
                    operator: operator ?? "EQ",
                    comparisonValue: value,
                    relationship,
                    isDeprecated,
                });
                return [countFilter];
            }
            if (fieldName === "node") {
                return this.createAggregationNodeFilters({
                    where: value,
                    relationship,
                    attachedTo: "node",
                    isDeprecated,
                });
            }
            if (fieldName === "edge" && relationship.propertiesTypeName) {
                // This conditional handles when the relationship is an interface which is also being accessed through an interface
                if ((0, is_interface_entity_1.isInterfaceEntity)(relationship.target) &&
                    Object.keys(value).some((v) => relationship.siblings?.includes(v))) {
                    return Object.entries(value).flatMap(([k, v]) => {
                        if (k === relationship.propertiesTypeName) {
                            return this.createAggregationNodeFilters({
                                where: v,
                                relationship,
                                attachedTo: "relationship",
                                isDeprecated,
                            });
                        }
                        return [];
                    });
                }
                return this.createAggregationNodeFilters({
                    where: value,
                    relationship,
                    attachedTo: "relationship",
                    isDeprecated,
                });
            }
            throw new Error(`Aggregation filter not found ${key}`);
        });
        return this.wrapMultipleFiltersInLogical(nestedFilters);
    }
    createAggregationFilter({ relationship, where, isDeprecated, }) {
        return this.wrapMultipleFiltersInLogical(this.getAggregationNestedFilters({ where, relationship, isDeprecated }));
    }
    createAggregationNodeFilters({ where, relationship, attachedTo, isDeprecated, }) {
        const filters = Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const filters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                    return this.createAggregationNodeFilters({
                        where: nestedWhere,
                        relationship,
                        attachedTo,
                        isDeprecated,
                    });
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters,
                });
            }
            const entity = (attachedTo === "node" ? relationship.target : relationship); // Union are not supported in aggregations.
            // NOTE: if aggregationOperator is undefined, maybe we could return a normal PropertyFilter instead
            const { fieldName, logicalOperator, aggregationOperator } = (0, parse_where_field_1.parseAggregationWhereFields)(key);
            const attr = entity.findAttribute(fieldName);
            if (!attr) {
                throw new Error(`Attribute ${fieldName} not found`);
            }
            if (!aggregationOperator) {
                const filters = Object.entries(value).flatMap(([aggregationOperator, value]) => {
                    const parsedAggregationOperation = this.parseGenericAggregationOperator(aggregationOperator);
                    // NOTE: this part is duplicate of the code used for non-generic operators
                    return Object.entries(value).map(([operator, value]) => {
                        const parsedOperator = this.parseGenericOperatorForAggregation(operator);
                        if (attr.typeHelper.isDuration()) {
                            return new AggregationDurationPropertyFilter_1.AggregationDurationFilter({
                                attribute: attr,
                                relationship: relationship,
                                comparisonValue: value,
                                logicalOperator: parsedOperator || "EQUAL",
                                aggregationOperator: parsedAggregationOperation,
                                attachedTo,
                                isDeprecated,
                            });
                        }
                        if (attr.typeHelper.isDateTime()) {
                            return new AggregationDateTimePropertyFilter_1.AggregationDateTimeFilter({
                                attribute: attr,
                                relationship: relationship,
                                comparisonValue: value,
                                logicalOperator: parsedOperator || "EQUAL",
                                aggregationOperator: parsedAggregationOperation,
                                attachedTo,
                                isDeprecated,
                            });
                        }
                        if (attr.typeHelper.isTime()) {
                            return new AggregationTimePropertyFilter_1.AggregationTimeFilter({
                                attribute: attr,
                                relationship: relationship,
                                comparisonValue: value,
                                logicalOperator: parsedOperator || "EQUAL",
                                aggregationOperator: parsedAggregationOperation,
                                attachedTo,
                                isDeprecated,
                            });
                        }
                        return new AggregationPropertyFilter_1.AggregationPropertyFilter({
                            attribute: attr,
                            relationship: relationship,
                            comparisonValue: value,
                            logicalOperator: parsedOperator || "EQUAL",
                            aggregationOperator: parsedAggregationOperation,
                            attachedTo,
                            isDeprecated,
                        });
                    });
                });
                return this.wrapMultipleFiltersInLogical(filters);
            }
            if (attr.typeHelper.isDuration()) {
                return new AggregationDurationPropertyFilter_1.AggregationDurationFilter({
                    attribute: attr,
                    relationship: relationship,
                    comparisonValue: value,
                    logicalOperator: logicalOperator || "EQUAL",
                    aggregationOperator: aggregationOperator,
                    attachedTo,
                    isDeprecated,
                });
            }
            if (attr.typeHelper.isDateTime()) {
                return new AggregationDateTimePropertyFilter_1.AggregationDateTimeFilter({
                    attribute: attr,
                    relationship: relationship,
                    comparisonValue: value,
                    logicalOperator: logicalOperator || "EQUAL",
                    aggregationOperator: aggregationOperator,
                    attachedTo,
                    isDeprecated,
                });
            }
            if (attr.typeHelper.isTime()) {
                return new AggregationTimePropertyFilter_1.AggregationTimeFilter({
                    attribute: attr,
                    relationship: relationship,
                    comparisonValue: value,
                    logicalOperator: logicalOperator || "EQUAL",
                    aggregationOperator: aggregationOperator,
                    attachedTo,
                    isDeprecated,
                });
            }
            return new AggregationPropertyFilter_1.AggregationPropertyFilter({
                attribute: attr,
                relationship: relationship,
                comparisonValue: value,
                logicalOperator: logicalOperator || "EQUAL",
                aggregationOperator: aggregationOperator,
                attachedTo,
                isDeprecated,
            });
        });
        return this.wrapMultipleFiltersInLogical(filters);
    }
    /** Returns an array of 0 or 1 elements with the filters wrapped using a logical operator if needed */
    wrapMultipleFiltersInLogical(filters, logicalOp = "AND") {
        if (filters.length > 1) {
            return [
                new LogicalFilter_1.LogicalFilter({
                    operation: logicalOp,
                    filters,
                }),
            ];
        }
        const singleFilter = filters[0];
        if (singleFilter) {
            return [singleFilter];
        }
        return [];
    }
    // This method identifies if it's possible to achieve MATCH (n)-[r]->(m) WHERE m:Movie Or m:Series rather than MATCH (n)-[r]->(m:Movie) Or MATCH (n)-[r]->(m:Series)
    // When filters contain a nested relationship filter this is no longer achievable as the relationship definition is not shared between each concrete entity.
    // For context check TCK test packages/graphql/tests/tck/issues/2709.test.ts --> "should not use a node label so it covers all nodes implementing the interface for connection rel".
    isLabelOptimizationForInterfacePossible(where, entity) {
        if (where.node) {
            const containsUnOptimizableFields = Object.keys(where.node).some((field) => {
                const { fieldName, isAggregate, isConnection } = (0, parse_where_field_1.parseWhereField)(field);
                if (isAggregate || isConnection) {
                    return true;
                }
                const relationshipDeclaration = entity.findRelationshipDeclarations(fieldName);
                if (relationshipDeclaration) {
                    return true;
                }
                return false;
            });
            return !containsUnOptimizableFields;
        }
        return true;
    }
    /** Converts new distance operator into traditional operator **/
    desugarGenericDistanceOperations(distance) {
        const point = distance.from;
        const targetPoint = {};
        // eslint-disable-next-line prefer-const
        for (let [key, value] of Object.entries(distance)) {
            if (key !== "from") {
                // We need this fake operator to differentiate distance from point eq in the
                // desugaring process. Not needed in other operators because they are always distance based
                if (key === "eq") {
                    key = "distance_eq";
                }
                targetPoint[key] = {
                    distance: value,
                    point,
                };
            }
        }
        return targetPoint;
    }
    parseGenericAggregationOperator(key) {
        // we convert them to the previous format to keep the same translation logic
        switch (key) {
            case "averageLength":
            case "average":
                return "AVERAGE";
            case "shortestLength":
            case "shortest":
                return "SHORTEST";
            case "longestLength":
            case "longest":
                return "LONGEST";
            case "min":
                return "MIN";
            case "max":
                return "MAX";
            case "sum":
                return "SUM";
            default:
                throw new Error(`Invalid aggregation operator ${key}`);
        }
    }
}
exports.FilterFactory = FilterFactory;
//# sourceMappingURL=FilterFactory.js.map