import Cypher from "@neo4j/cypher-builder";
import type { AttributeAdapter } from "../../../schema-model/attribute/model-adapters/AttributeAdapter";
import type { EntityAdapter } from "../../../schema-model/entity/EntityAdapter";
import type { ConcreteEntityAdapter } from "../../../schema-model/entity/model-adapters/ConcreteEntityAdapter";
import type { InterfaceEntityAdapter } from "../../../schema-model/entity/model-adapters/InterfaceEntityAdapter";
import type { UnionEntityAdapter } from "../../../schema-model/entity/model-adapters/UnionEntityAdapter";
import type { RelationshipAdapter } from "../../../schema-model/relationship/model-adapters/RelationshipAdapter";
import type { GraphQLWhereArg } from "../../../types";
import { ConnectionFilter } from "../ast/filters/ConnectionFilter";
import { CypherOneToOneRelationshipFilter } from "../ast/filters/CypherOneToOneRelationshipFilter";
import { CypherRelationshipFilter } from "../ast/filters/CypherRelationshipFilter";
import type { Filter, FilterOperator, RelationshipWhereOperator } from "../ast/filters/Filter";
import { LogicalFilter } from "../ast/filters/LogicalFilter";
import { RelationshipFilter } from "../ast/filters/RelationshipFilter";
import { CustomCypherSelection } from "../ast/selection/CustomCypherSelection";
import type { QueryASTFactory } from "./QueryASTFactory";
export declare class FilterFactory {
    private queryASTFactory;
    constructor(queryASTFactory: QueryASTFactory);
    private createConnectionFilter;
    createConnectionPredicates({ rel, entity, where, partialOf, }: {
        rel?: RelationshipAdapter;
        entity: EntityAdapter;
        where: GraphQLWhereArg | GraphQLWhereArg[];
        partialOf?: InterfaceEntityAdapter | UnionEntityAdapter;
    }): Filter[];
    private createCypherFilter;
    protected createPropertyFilter({ attribute, relationship, comparisonValue, operator, attachedTo, }: {
        attribute: AttributeAdapter;
        relationship?: RelationshipAdapter;
        comparisonValue: GraphQLWhereArg;
        operator: FilterOperator | undefined;
        attachedTo?: "node" | "relationship";
    }): Filter | Filter[];
    private createRelationshipFilter;
    protected createCypherRelationshipFilter({ selection, target, where, attribute, operator, }: {
        selection: CustomCypherSelection;
        target: EntityAdapter;
        where: GraphQLWhereArg;
        operator: RelationshipWhereOperator | undefined;
        attribute: AttributeAdapter;
    }): Filter[];
    protected createCypherOneToOneRelationshipFilterTreeNode(options: {
        selection: CustomCypherSelection;
        attribute: AttributeAdapter;
        isNull: boolean;
        operator: RelationshipWhereOperator;
        returnVariable: Cypher.Node;
    }): CypherOneToOneRelationshipFilter;
    protected createCypherRelationshipFilterTreeNode(options: {
        selection: CustomCypherSelection;
        attribute: AttributeAdapter;
        isNull: boolean;
        operator: RelationshipWhereOperator;
        returnVariable: Cypher.Node;
    }): CypherRelationshipFilter;
    protected createRelationshipFilterTreeNode(options: {
        relationship: RelationshipAdapter;
        target: ConcreteEntityAdapter | InterfaceEntityAdapter;
        operator: RelationshipWhereOperator;
    }): RelationshipFilter;
    protected createConnectionFilterTreeNode(options: {
        relationship: RelationshipAdapter;
        target: ConcreteEntityAdapter | InterfaceEntityAdapter;
        operator: RelationshipWhereOperator;
    }): ConnectionFilter;
    createInterfaceNodeFilters({ entity, targetEntity, whereFields, relationship, }: {
        entity: InterfaceEntityAdapter;
        targetEntity?: ConcreteEntityAdapter;
        whereFields: Record<string, any>;
        relationship?: RelationshipAdapter;
    }): Filter[];
    createNodeFilters(entity: ConcreteEntityAdapter | UnionEntityAdapter, whereFields: Record<string, any>): Filter[];
    private parseEntryFilter;
    private parseGenericFilters;
    private parseGenericFilter;
    protected parseGenericOperator(key: string): FilterOperator;
    private parseGenericOperatorForAggregation;
    protected convertRelationshipOperatorToLegacyOperator(operator: string): RelationshipWhereOperator;
    private createRelatedNodeFilters;
    private getLogicalOperatorForRelatedNodeFilters;
    private createRelayIdPropertyFilter;
    createEdgeFilters(relationship: RelationshipAdapter, where: GraphQLWhereArg): Filter[];
    private createCountFilter;
    private parseConnectionAggregationCountFilter;
    private getAggregationNestedFilters;
    private createAggregationFilter;
    private createAggregationNodeFilters;
    /** Returns an array of 0 or 1 elements with the filters wrapped using a logical operator if needed */
    protected wrapMultipleFiltersInLogical<F extends Filter>(filters: F[], logicalOp?: "AND" | "OR" | "XOR"): [F | LogicalFilter] | [];
    private isLabelOptimizationForInterfacePossible;
    /** Converts new distance operator into traditional operator **/
    private desugarGenericDistanceOperations;
    private parseGenericAggregationOperator;
}
//# sourceMappingURL=FilterFactory.d.ts.map