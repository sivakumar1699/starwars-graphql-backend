"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FulltextFactory = void 0;
const check_authentication_1 = require("../../../authorization/check-authentication");
const ScoreField_1 = require("../../ast/fields/ScoreField");
const ScoreFilter_1 = require("../../ast/filters/property-filters/ScoreFilter");
const FulltextOperation_1 = require("../../ast/operations/FulltextOperation");
const FulltextSelection_1 = require("../../ast/selection/FulltextSelection");
const find_fields_by_name_in_fields_by_type_name_field_1 = require("../parsers/find-fields-by-name-in-fields-by-type-name-field");
const get_fields_by_type_name_1 = require("../parsers/get-fields-by-type-name");
class FulltextFactory {
    constructor(queryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }
    createFulltextOperation(entity, resolveTree, context) {
        const resolveTreeWhere = this.queryASTFactory.operationsFactory.getWhereArgs(resolveTree) ?? {};
        (0, check_authentication_1.checkEntityAuthentication)({
            entity: entity.entity,
            targetOperations: ["READ"],
            context,
        });
        let scoreField;
        const fulltextConnectionFields = resolveTree.fieldsByTypeName[entity.operations.fulltextTypeNames.connection];
        if (!fulltextConnectionFields) {
            throw new Error("Fulltext result field not found");
        }
        const filteredResolveTreeEdges = (0, find_fields_by_name_in_fields_by_type_name_field_1.findFieldsByNameInFieldsByTypeNameField)(fulltextConnectionFields, "edges");
        const edgeFields = (0, get_fields_by_type_name_1.getFieldsByTypeName)(filteredResolveTreeEdges, entity.operations.fulltextTypeNames.edge);
        const scoreFields = (0, find_fields_by_name_in_fields_by_type_name_field_1.findFieldsByNameInFieldsByTypeNameField)(edgeFields, "score");
        // We only care about the first score field
        if (scoreFields.length > 0 && scoreFields[0] && context.fulltext) {
            scoreField = new ScoreField_1.ScoreField({
                alias: scoreFields[0].alias,
                score: context.fulltext.scoreVariable,
            });
        }
        const operation = new FulltextOperation_1.FulltextOperation({
            target: entity,
            scoreField,
            selection: this.getFulltextSelection(entity, context),
        });
        const concreteEdgeFields = (0, get_fields_by_type_name_1.getFieldsByTypeName)(filteredResolveTreeEdges, entity.operations.fulltextTypeNames.edge);
        this.addFulltextScoreFilter({
            operation,
            context,
            whereArgs: resolveTreeWhere,
        });
        this.queryASTFactory.operationsFactory.hydrateConnectionOperation({
            target: entity,
            resolveTree: resolveTree,
            context,
            operation,
            whereArgs: resolveTreeWhere,
            resolveTreeEdgeFields: concreteEdgeFields,
        });
        return operation;
    }
    addFulltextScoreFilter({ operation, whereArgs, context, }) {
        if (whereArgs.score && context?.fulltext) {
            const scoreFilter = new ScoreFilter_1.ScoreFilter({
                scoreVariable: context.fulltext.scoreVariable,
                min: whereArgs.score.min,
                max: whereArgs.score.max,
            });
            operation.addFilters(scoreFilter);
        }
    }
    getFulltextSelection(entity, context) {
        const fulltextOptions = this.getFulltextOptions(context);
        return new FulltextSelection_1.FulltextSelection({
            target: entity,
            fulltextOptions,
            scoreVariable: fulltextOptions.score,
        });
    }
    getFulltextOptions(context) {
        if (!context.fulltext) {
            throw new Error("Fulltext context is missing");
        }
        const phrase = context.resolveTree.args.phrase;
        if (!phrase || typeof phrase !== "string") {
            throw new Error("Invalid phrase");
        }
        return {
            index: context.fulltext.index,
            phrase,
            score: context.fulltext.scoreVariable,
        };
    }
}
exports.FulltextFactory = FulltextFactory;
//# sourceMappingURL=FulltextFactory.js.map