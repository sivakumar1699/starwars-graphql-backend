"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateFactory = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const utils_1 = require("../../../../utils/utils");
const MutationOperationField_1 = require("../../ast/input-fields/MutationOperationField");
const PropertyInputField_1 = require("../../ast/input-fields/PropertyInputField");
const CreateOperation_1 = require("../../ast/operations/CreateOperation");
const UnwindCreateOperation_1 = require("../../ast/operations/UnwindCreateOperation");
const is_concrete_entity_1 = require("../../utils/is-concrete-entity");
const raise_attribute_ambiguity_1 = require("../../utils/raise-attribute-ambiguity");
const get_autogenerated_fields_1 = require("../parsers/get-autogenerated-fields");
class CreateFactory {
    constructor(queryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }
    createCreateOperation(entity, resolveTree, context) {
        const responseFields = Object.values(resolveTree.fieldsByTypeName[entity.operations.mutationResponseTypeNames.create] ?? {});
        const createOP = new CreateOperation_1.CreateOperation({ target: entity });
        const projectionFields = responseFields
            .filter((f) => f.name === entity.plural)
            .map((field) => {
            const readOP = this.queryASTFactory.operationsFactory.createReadOperation({
                entityOrRel: entity,
                resolveTree: field,
                context,
            });
            return readOP;
        });
        createOP.addProjectionOperations(projectionFields);
        return createOP;
    }
    createUnwindCreateOperation(entity, resolveTree, context) {
        const responseFields = Object.values(resolveTree.fieldsByTypeName[entity.operations.mutationResponseTypeNames.create] ?? {});
        const rawInput = resolveTree.args.input;
        const input = rawInput ?? [];
        const unwindCreate = this.parseUnwindCreate({
            target: entity,
            input,
            context,
            argumentToUnwind: new cypher_builder_1.default.Param(input),
        });
        const projectionFields = responseFields
            .filter((f) => f.name === entity.plural)
            .map((field) => {
            return this.queryASTFactory.operationsFactory.createReadOperation({
                entityOrRel: entity,
                resolveTree: field,
                context,
            });
        });
        unwindCreate.addProjectionOperations(projectionFields);
        return unwindCreate;
    }
    parseUnwindCreate({ target, relationship, input, context, argumentToUnwind, }) {
        const isNested = Boolean(relationship);
        const unwindCreate = new UnwindCreateOperation_1.UnwindCreateOperation({
            target: relationship ?? target,
            argumentToUnwind,
        });
        this.addEntityAuthorization({ entity: target, context, unwindCreate: unwindCreate });
        this.addAuthorizationsForAttributes({
            target,
            context,
            unwindCreate: unwindCreate,
            isNested,
        });
        this.hydrateUnwindCreateOperation({
            target,
            relationship,
            input,
            unwindCreate,
            context,
        });
        return unwindCreate;
    }
    hydrateUnwindCreateOperation({ target, relationship, input, unwindCreate, context, }) {
        const isNested = Boolean(relationship);
        // TODO: there is no need to get always the autogenerated field as these are static fields and can be cached
        [target, relationship].forEach((t) => this.addAutogeneratedFields({
            target: t,
            unwindCreate,
        }));
        (0, utils_1.asArray)(input).forEach((inputItem) => {
            const targetInput = this.getInputNode(inputItem, isNested);
            (0, raise_attribute_ambiguity_1.raiseAttributeAmbiguity)(Object.keys(targetInput), target);
            (0, raise_attribute_ambiguity_1.raiseAttributeAmbiguity)(Object.keys(this.getInputEdge(target)), relationship);
            for (const key of Object.keys(targetInput)) {
                const nestedRelationship = target.relationships.get(key);
                const attribute = target.attributes.get(key);
                if (!attribute && !nestedRelationship) {
                    throw new Error(`Transpile Error: Input field ${key} not found in entity ${target.name}`);
                }
                if (attribute) {
                    this.parseAttributeInputField({
                        target,
                        attribute,
                        unwindCreate,
                    });
                }
                else if (nestedRelationship) {
                    const nestedEntity = nestedRelationship.target;
                    (0, is_concrete_entity_1.assertIsConcreteEntity)(nestedEntity);
                    const relField = unwindCreate.getField(key, "node");
                    const nestedCreateInput = targetInput[key]?.create;
                    if (relField &&
                        relField instanceof MutationOperationField_1.MutationOperationField &&
                        relField.mutationOperation instanceof UnwindCreateOperation_1.UnwindCreateOperation) {
                        // in case relationship field is already present in the unwind operation we want still to hydrate the unwind-create operation as it might have different fields.
                        this.hydrateUnwindCreateOperation({
                            target: nestedEntity,
                            relationship: nestedRelationship,
                            input: nestedCreateInput,
                            unwindCreate: relField.mutationOperation,
                            context,
                        });
                    }
                    else {
                        this.addRelationshipInputFieldToUnwindOperation({
                            relationship: nestedRelationship,
                            unwindCreate,
                            context,
                            nestedCreateInput,
                            isNested,
                        });
                    }
                }
            }
            if (relationship) {
                for (const key of Object.keys(this.getInputEdge(inputItem))) {
                    const attribute = relationship.attributes.get(key);
                    if (attribute) {
                        this.parseAttributeInputField({
                            target: relationship,
                            attribute,
                            unwindCreate,
                        });
                    }
                }
            }
        });
    }
    getInputNode(inputItem, isNested) {
        if (isNested) {
            return inputItem.node ?? {};
        }
        return inputItem;
    }
    getInputEdge(inputItem) {
        return inputItem.edge ?? {};
    }
    addAutogeneratedFields({ target, unwindCreate, }) {
        if (!target) {
            return;
        }
        const attachedTo = (0, is_concrete_entity_1.isConcreteEntity)(target) ? "node" : "relationship";
        const autoGeneratedFields = (0, get_autogenerated_fields_1.getAutogeneratedFields)(target);
        autoGeneratedFields.forEach((field) => {
            if (unwindCreate.getField(field.name, attachedTo)) {
                return;
            }
            unwindCreate.addField(field, attachedTo);
        });
    }
    parseAttributeInputField({ target, attribute, unwindCreate, }) {
        const isConcreteEntityTarget = (0, is_concrete_entity_1.isConcreteEntity)(target);
        const attachedTo = isConcreteEntityTarget ? "node" : "relationship";
        this.addAttributeInputFieldToUnwindOperation({
            attribute,
            unwindCreate,
            pathStr: isConcreteEntityTarget ? "edge" : "node",
            attachedTo,
        });
    }
    getEdgeOrNodePath({ unwindVariable, isNested, isRelField, }) {
        if (!isNested && isRelField) {
            throw new Error("Transpile error: invalid invoke of getEdgeOrNodePath for relationship field.");
        }
        if (isNested) {
            const path = isRelField ? "edge" : "node";
            return unwindVariable.property(path);
        }
        return unwindVariable;
    }
    addAttributeInputFieldToUnwindOperation({ attribute, unwindCreate, attachedTo, }) {
        if (unwindCreate.getField(attribute.name, attachedTo)) {
            return;
        }
        const inputField = new PropertyInputField_1.PropertyInputField({
            attribute,
            attachedTo,
        });
        unwindCreate.addField(inputField, attachedTo);
    }
    addRelationshipInputFieldToUnwindOperation({ relationship, unwindCreate, context, nestedCreateInput, isNested, }) {
        const relField = unwindCreate.getField(relationship.name, "node");
        if (!relField) {
            if (nestedCreateInput) {
                const partialPath = this.getEdgeOrNodePath({
                    unwindVariable: unwindCreate.getUnwindVariable(),
                    isNested,
                    isRelField: false,
                });
                const path = partialPath.property(relationship.name).property("create");
                const nestedUnwind = this.parseUnwindCreate({
                    target: relationship.target,
                    relationship: relationship,
                    input: nestedCreateInput,
                    argumentToUnwind: path,
                    context,
                });
                const mutationOperationField = new MutationOperationField_1.MutationOperationField(relationship.name, nestedUnwind);
                unwindCreate.addField(mutationOperationField, "node");
            }
            else {
                throw new Error(`Expected create operation, but found: ${relationship.name}`);
            }
        }
    }
    addEntityAuthorization({ entity, context, unwindCreate, }) {
        const authFilters = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            authAnnotation: entity.annotations.authorization,
            when: "AFTER",
            operations: ["CREATE"],
            context,
        });
        if (authFilters) {
            unwindCreate.addAuthFilters(authFilters);
        }
    }
    addAttributeAuthorization({ attribute, context, unwindCreate, entity, conditionForEvaluation, }) {
        const attributeAuthorization = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            when: "AFTER",
            authAnnotation: attribute.annotations.authorization,
            conditionForEvaluation,
            operations: ["CREATE"],
            context,
        });
        if (attributeAuthorization) {
            unwindCreate.addAuthFilters(attributeAuthorization);
        }
    }
    addAuthorizationsForAttributes({ target, context, unwindCreate, isNested, }) {
        const edgeOrNodePath = this.getEdgeOrNodePath({
            unwindVariable: unwindCreate.getUnwindVariable(),
            isRelField: false,
            isNested,
        });
        for (const attribute of target.attributes.values()) {
            const path = edgeOrNodePath.property(attribute.name);
            this.addAttributeAuthorization({
                attribute,
                context,
                unwindCreate,
                entity: target,
                conditionForEvaluation: cypher_builder_1.default.isNotNull(path),
            });
        }
    }
}
exports.CreateFactory = CreateFactory;
//# sourceMappingURL=CreateFactory.js.map