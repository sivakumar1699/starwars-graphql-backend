import type { FieldsByTypeName, ResolveTree } from "graphql-parse-resolve-info";
import { Integer } from "neo4j-driver";
import type { AttributeAdapter } from "../../../schema-model/attribute/model-adapters/AttributeAdapter";
import type { EntityAdapter } from "../../../schema-model/entity/EntityAdapter";
import type { ConcreteEntityAdapter } from "../../../schema-model/entity/model-adapters/ConcreteEntityAdapter";
import type { InterfaceEntityAdapter } from "../../../schema-model/entity/model-adapters/InterfaceEntityAdapter";
import type { UnionEntityAdapter } from "../../../schema-model/entity/model-adapters/UnionEntityAdapter";
import type { RelationshipAdapter } from "../../../schema-model/relationship/model-adapters/RelationshipAdapter";
import type { GraphQLSortingAndPaginationArgs } from "../../../types";
import type { Neo4jGraphQLTranslationContext } from "../../../types/neo4j-graphql-translation-context";
import type { Filter } from "../ast/filters/Filter";
import type { AggregationOperation } from "../ast/operations/AggregationOperation";
import type { ConnectionReadOperation } from "../ast/operations/ConnectionReadOperation";
import type { CypherAttributeOperation } from "../ast/operations/CypherAttributeOperation";
import type { CypherEntityOperation } from "../ast/operations/CypherEntityOperation";
import type { ReadOperation } from "../ast/operations/ReadOperation";
import type { CompositeAggregationOperation } from "../ast/operations/composite/CompositeAggregationOperation";
import type { CompositeConnectionReadOperation } from "../ast/operations/composite/CompositeConnectionReadOperation";
import type { CompositeCypherOperation } from "../ast/operations/composite/CompositeCypherOperation";
import type { CompositeReadOperation } from "../ast/operations/composite/CompositeReadOperation";
import type { Operation } from "../ast/operations/operations";
import type { FulltextSelection } from "../ast/selection/FulltextSelection";
import type { VectorSelection } from "../ast/selection/VectorSelection";
import type { QueryASTFactory } from "./QueryASTFactory";
export declare class OperationsFactory {
    private filterFactory;
    private fieldFactory;
    private sortAndPaginationFactory;
    private authorizationFactory;
    private createFactory;
    private updateFactory;
    private deleteFactory;
    private fulltextFactory;
    private aggregateFactory;
    private customCypherFactory;
    private connectionFactory;
    private readFactory;
    private vectorFactory;
    constructor(queryASTFactory: QueryASTFactory);
    createTopLevelOperation({ entity, resolveTree, context, varName, reference, resolveAsUnwind, }: {
        entity?: EntityAdapter;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
        varName?: string;
        reference?: any;
        resolveAsUnwind?: boolean;
    }): Operation;
    /**
     *  Proxy methods to specialized operations factories.
     *  TODO: Refactor the following to use a generic dispatcher as done in createTopLevelOperation
     **/
    createReadOperation(arg: {
        entityOrRel: EntityAdapter | RelationshipAdapter;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
        varName?: string;
        reference?: any;
    }): ReadOperation | CompositeReadOperation;
    getFulltextSelection(entity: ConcreteEntityAdapter, context: Neo4jGraphQLTranslationContext): FulltextSelection;
    getVectorSelection(entity: ConcreteEntityAdapter, context: Neo4jGraphQLTranslationContext): VectorSelection;
    createAggregationOperation(entityOrRel: ConcreteEntityAdapter | RelationshipAdapter | InterfaceEntityAdapter, resolveTree: ResolveTree, context: Neo4jGraphQLTranslationContext): AggregationOperation | CompositeAggregationOperation;
    splitConnectionFields(rawFields: Record<string, ResolveTree>): {
        node: ResolveTree | undefined;
        edge: ResolveTree | undefined;
        fields: Record<string, ResolveTree>;
    };
    createConnectionOperationAST(arg: {
        relationship?: RelationshipAdapter;
        target: ConcreteEntityAdapter;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
    }): ConnectionReadOperation | CompositeConnectionReadOperation;
    createCompositeConnectionOperationAST(arg: {
        relationship?: RelationshipAdapter;
        target: InterfaceEntityAdapter | UnionEntityAdapter;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
    }): CompositeConnectionReadOperation;
    hydrateReadOperation<T extends ReadOperation>(arg: {
        entity: ConcreteEntityAdapter;
        operation: T;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
        whereArgs: Record<string, any> | Filter[];
        partialOf?: InterfaceEntityAdapter | UnionEntityAdapter;
    }): T;
    hydrateConnectionOperation<T extends ConnectionReadOperation>(arg: {
        relationship?: RelationshipAdapter;
        target: ConcreteEntityAdapter;
        resolveTree: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
        operation: T;
        whereArgs: Record<string, any>;
        resolveTreeEdgeFields: Record<string, ResolveTree>;
        partialOf?: InterfaceEntityAdapter | UnionEntityAdapter;
    }): T;
    createCustomCypherOperation(arg: {
        resolveTree?: ResolveTree;
        context: Neo4jGraphQLTranslationContext;
        entity?: EntityAdapter;
        cypherAttributeField: AttributeAdapter;
        cypherArguments?: Record<string, any>;
    }): CypherEntityOperation | CompositeCypherOperation | CypherAttributeOperation;
    /**
     * END of proxy methods
     **/
    hydrateOperation<T extends ReadOperation>({ entity, operation, whereArgs, context, paginationArgs, fieldsByTypeName, partialOf, }: {
        entity: ConcreteEntityAdapter;
        operation: T;
        context: Neo4jGraphQLTranslationContext;
        whereArgs: Record<string, any>;
        paginationArgs?: Record<"limit" | "offset" | "sort", any>;
        fieldsByTypeName: FieldsByTypeName;
        partialOf?: UnionEntityAdapter | InterfaceEntityAdapter;
    }): T;
    getOptions({ entity, limitArg, offsetArg, sortArg, }: {
        entity: EntityAdapter;
        limitArg: number | Integer;
        offsetArg: number;
        sortArg: Record<string, any>[];
    }): GraphQLSortingAndPaginationArgs | undefined;
    getSelectedAttributes(entity: ConcreteEntityAdapter, rawFields: Record<string, ResolveTree>): AttributeAdapter[];
    getWhereArgs(resolveTree: ResolveTree, reference?: any): Record<string, any>;
}
//# sourceMappingURL=OperationFactory.d.ts.map