"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelationshipFilter = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const typescript_memoize_1 = require("typescript-memoize");
const utils_1 = require("../../../../utils/utils");
const create_node_from_entity_1 = require("../../utils/create-node-from-entity");
const wrap_subquery_in_calls_1 = require("../../utils/wrap-subquery-in-calls");
const Filter_1 = require("./Filter");
class RelationshipFilter extends Filter_1.Filter {
    constructor({ relationship, operator, target, }) {
        super();
        this.targetNodeFilters = [];
        /** Variable to be used if relationship need to get the count (i.e. 1-1 relationships) */
        this.countVariable = new cypher_builder_1.default.Variable();
        this.relationship = relationship;
        this.operator = operator;
        this.target = target;
    }
    getChildren() {
        return this.targetNodeFilters;
    }
    addTargetNodeFilter(...filter) {
        this.targetNodeFilters.push(...filter);
    }
    print() {
        return `${super.print()} [${this.relationship.name}] <${this.operator}>`;
    }
    getNestedContext(context) {
        const target = new cypher_builder_1.default.Node();
        const relationship = new cypher_builder_1.default.Relationship();
        const nestedContext = context.push({
            target,
            relationship,
        });
        return nestedContext;
    }
    getNestedSelectionSubqueries(context) {
        const returnVars = [];
        const nestedSelection = (0, utils_1.filterTruthy)(this.targetNodeFilters.map((f) => {
            if (!context.hasTarget()) {
                throw new Error("No parent node found!");
            }
            const selection = f.getSelection(context);
            if (selection.length === 0) {
                return;
            }
            const pattern = new cypher_builder_1.default.Pattern(context.source)
                .related({
                type: this.relationship.type,
                direction: this.relationship.getCypherDirection(),
            })
                .to(context.target, {
                labels: (0, create_node_from_entity_1.getEntityLabels)(this.target, context.neo4jGraphQLContext),
            });
            const relationshipMatch = new cypher_builder_1.default.Match(pattern);
            const countVar = new cypher_builder_1.default.Variable();
            returnVars.push(countVar);
            const predicate = f.getPredicate(context);
            const withClause = new cypher_builder_1.default.With("*");
            if (predicate)
                withClause.where(predicate);
            let returnCondition;
            if (!this.relationship.isList) {
                returnCondition = cypher_builder_1.default.eq(cypher_builder_1.default.count(context.target), new cypher_builder_1.default.Literal(1));
            }
            else {
                returnCondition = cypher_builder_1.default.gt(cypher_builder_1.default.count(context.target), new cypher_builder_1.default.Literal(0));
            }
            withClause.return([returnCondition, countVar]);
            return cypher_builder_1.default.utils.concat(relationshipMatch, ...selection, withClause);
        }));
        const predicates = returnVars.map((v) => cypher_builder_1.default.eq(v, cypher_builder_1.default.true));
        this.subqueryPredicate = cypher_builder_1.default.and(...predicates);
        return nestedSelection;
    }
    getSubqueries(context) {
        // NOTE: not using getNestedContext because this should not be memoized in ALL operations
        const target = new cypher_builder_1.default.Node();
        const relationship = new cypher_builder_1.default.Relationship();
        const nestedContext = context.push({
            target,
            relationship,
        });
        const subqueries = [];
        const nestedSubqueries = this.targetNodeFilters.flatMap((f) => f.getSubqueries(nestedContext));
        const nestedSelection = this.getNestedSelectionSubqueries(nestedContext);
        if (nestedSubqueries.length > 0) {
            subqueries.push(...this.getNestedSubqueries(nestedContext));
        }
        if (nestedSelection.length > 0) {
            subqueries.push(...nestedSelection);
        }
        return subqueries;
    }
    getNestedSubqueries(context) {
        const pattern = new cypher_builder_1.default.Pattern(context.source)
            .related({
            direction: this.relationship.getCypherDirection(),
            type: this.relationship.type,
        })
            .to(context.target, {
            labels: (0, create_node_from_entity_1.getEntityLabels)(this.target, context.neo4jGraphQLContext),
        });
        switch (this.operator) {
            case "NONE":
            case "SOME":
            case "SINGLE": {
                if (!context.hasTarget()) {
                    throw new Error("No parent node found!");
                }
                const match = new cypher_builder_1.default.Match(pattern);
                const returnVar = new cypher_builder_1.default.Variable();
                const nestedSubqueries = (0, wrap_subquery_in_calls_1.wrapSubqueriesInCypherCalls)(context, this.targetNodeFilters, [context.target]);
                const subqueriesFilters = this.targetNodeFilters.map((f) => f.getPredicate(context));
                const subqueriesPredicate = cypher_builder_1.default.and(...subqueriesFilters);
                const comparator = this.operator === "NONE" ? cypher_builder_1.default.false : cypher_builder_1.default.true;
                this.subqueryPredicate = cypher_builder_1.default.eq(returnVar, comparator);
                const withAfterSubqueries = new cypher_builder_1.default.With("*");
                if (subqueriesPredicate) {
                    withAfterSubqueries.where(subqueriesPredicate);
                }
                const returnPredicate = this.getNestedSubqueryFilter(context.target);
                withAfterSubqueries.return([returnPredicate, returnVar]);
                return [cypher_builder_1.default.utils.concat(match, ...nestedSubqueries, withAfterSubqueries)];
            }
            case "ALL": {
                const { clause: nestedSubqueries, returnVariables: truthyReturn } = this.getSubqueryForAllFilter(pattern, context, false);
                const { clause: nestedSubqueries2, returnVariables: falsyReturn } = this.getSubqueryForAllFilter(pattern, context, true);
                this.subqueryPredicate = cypher_builder_1.default.and(...falsyReturn.map((v) => cypher_builder_1.default.eq(v, cypher_builder_1.default.false)), ...truthyReturn.map((v) => cypher_builder_1.default.eq(v, cypher_builder_1.default.true)));
                return [nestedSubqueries, nestedSubqueries2];
            }
        }
    }
    getSubqueryForAllFilter(pattern, context, notPredicate) {
        const returnVariables = [];
        const match = new cypher_builder_1.default.Match(pattern);
        const subqueries = this.targetNodeFilters.map((f) => {
            if (!context.hasTarget()) {
                throw new Error("No parent node found!");
            }
            const returnVar = new cypher_builder_1.default.Variable();
            returnVariables.push(returnVar);
            const nestedSubqueries = f.getSubqueries(context).map((sq) => {
                return new cypher_builder_1.default.Call(sq).importWith(context.target);
            });
            let predicate = f.getPredicate(context);
            if (predicate && notPredicate) {
                predicate = cypher_builder_1.default.not(predicate);
            }
            const withClause = new cypher_builder_1.default.With("*");
            if (predicate) {
                withClause.where(predicate);
            }
            withClause.return([cypher_builder_1.default.gt(cypher_builder_1.default.count(context.target), new cypher_builder_1.default.Literal(0)), returnVar]); // THis variable needs to be used in predicate
            return cypher_builder_1.default.utils.concat(...nestedSubqueries, withClause);
        });
        return { clause: cypher_builder_1.default.utils.concat(match, ...subqueries), returnVariables };
    }
    getNestedSubqueryFilter(target) {
        switch (this.operator) {
            case "NONE":
            case "SOME":
                return cypher_builder_1.default.gt(cypher_builder_1.default.count(target), new cypher_builder_1.default.Literal(0));
            case "SINGLE":
                return cypher_builder_1.default.eq(cypher_builder_1.default.count(target), new cypher_builder_1.default.Literal(1));
            case "ALL":
                throw new Error("Not supported");
        }
    }
    getPredicate(queryASTContext) {
        if (this.subqueryPredicate) {
            return this.subqueryPredicate;
        }
        const nestedContext = this.getNestedContext(queryASTContext);
        const pattern = new cypher_builder_1.default.Pattern(nestedContext.source)
            .related({
            type: this.relationship.type,
            direction: this.relationship.getCypherDirection(),
        })
            .to(nestedContext.target, {
            labels: (0, create_node_from_entity_1.getEntityLabels)(this.target, nestedContext.neo4jGraphQLContext),
        });
        const predicate = this.createRelationshipOperation(pattern, nestedContext);
        return predicate;
    }
    getSingleRelationshipOperation({ pattern, queryASTContext, innerPredicate, }) {
        if (!queryASTContext.hasTarget()) {
            throw new Error("No parent node found!");
        }
        const patternComprehension = new cypher_builder_1.default.PatternComprehension(pattern)
            .map(new cypher_builder_1.default.Literal(1))
            .where(innerPredicate);
        return cypher_builder_1.default.single(queryASTContext.target, patternComprehension, new cypher_builder_1.default.Literal(true));
    }
    createRelationshipOperation(pattern, queryASTContext) {
        const predicates = this.targetNodeFilters.map((c) => c.getPredicate(queryASTContext));
        const innerPredicate = cypher_builder_1.default.and(...predicates);
        switch (this.operator) {
            case "ALL": {
                if (!innerPredicate) {
                    return;
                }
                const match = new cypher_builder_1.default.Match(pattern).where(innerPredicate);
                const negativeMatch = new cypher_builder_1.default.Match(pattern).where(cypher_builder_1.default.not(innerPredicate));
                // Testing "ALL" requires testing that at least one element exists and that no elements not matching the filter exists
                return cypher_builder_1.default.and(new cypher_builder_1.default.Exists(match), cypher_builder_1.default.not(new cypher_builder_1.default.Exists(negativeMatch)));
            }
            case "SINGLE": {
                if (!innerPredicate) {
                    return;
                }
                return this.getSingleRelationshipOperation({
                    pattern,
                    queryASTContext,
                    innerPredicate,
                });
            }
            case "NONE":
            case "SOME": {
                const match = new cypher_builder_1.default.Match(pattern);
                if (innerPredicate) {
                    match.where(innerPredicate);
                }
                const exists = new cypher_builder_1.default.Exists(match);
                if (this.operator === "NONE") {
                    return cypher_builder_1.default.not(exists);
                }
                return exists;
            }
        }
    }
}
exports.RelationshipFilter = RelationshipFilter;
__decorate([
    (0, typescript_memoize_1.Memoize)()
], RelationshipFilter.prototype, "getNestedContext", null);
//# sourceMappingURL=RelationshipFilter.js.map