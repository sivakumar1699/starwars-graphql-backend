"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthorizationAfterPredicate = createAuthorizationAfterPredicate;
exports.createAuthorizationAfterPredicateField = createAuthorizationAfterPredicateField;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const get_entity_adapter_from_node_1 = require("../../utils/get-entity-adapter-from-node");
const utils_1 = require("../../utils/utils");
const QueryASTContext_1 = require("../queryAST/ast/QueryASTContext");
const QueryASTFactory_1 = require("../queryAST/factory/QueryASTFactory");
const is_concrete_entity_1 = require("../queryAST/utils/is-concrete-entity");
const wrap_subquery_in_call_1 = require("../queryAST/utils/wrap-subquery-in-call");
function createAuthorizationAfterPredicate({ context, nodes, operations, }) {
    const predicates = [];
    let subqueries;
    for (const nodeEntry of nodes) {
        const node = nodeEntry.node;
        const matchNode = nodeEntry.variable;
        const entity = (0, get_entity_adapter_from_node_1.getEntityAdapterFromNode)(node, context);
        if (!(0, is_concrete_entity_1.isConcreteEntity)(entity)) {
            throw new Error("Expected authorization rule to be applied on a concrete entity");
        }
        const factory = new QueryASTFactory_1.QueryASTFactory(context.schemaModel);
        const queryASTEnv = new QueryASTContext_1.QueryASTEnv();
        const queryASTContext = new QueryASTContext_1.QueryASTContext({
            target: matchNode,
            env: queryASTEnv,
            neo4jGraphQLContext: context,
        });
        const authorizationFilters = factory.authorizationFactory.createAuthValidateRule({
            authAnnotation: entity.annotations.authorization,
            entity,
            operations,
            context,
            when: "AFTER",
        });
        const nodeRawSubqueries = authorizationFilters?.getSubqueries(queryASTContext);
        const nodeSubqueries = (0, utils_1.asArray)(nodeRawSubqueries).map((sq) => (0, wrap_subquery_in_call_1.wrapSubqueryInCall)(sq, matchNode));
        const nodePredicate = authorizationFilters?.getPredicate(queryASTContext);
        if (nodePredicate) {
            predicates.push(nodePredicate);
        }
        const extraSelections = authorizationFilters?.getSelection(queryASTContext);
        const preComputedSubqueries = [...(0, utils_1.asArray)(extraSelections), ...(0, utils_1.asArray)(nodeSubqueries)];
        if (preComputedSubqueries) {
            subqueries = cypher_builder_1.default.utils.concat(subqueries, ...preComputedSubqueries);
        }
    }
    if (!predicates.length) {
        return;
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
function createAuthorizationAfterPredicateField({ context, nodes, operations, conditionForEvaluation, }) {
    const predicates = [];
    let subqueries;
    for (const nodeEntry of nodes) {
        const node = nodeEntry.node;
        const matchNode = nodeEntry.variable;
        const fieldName = nodeEntry.fieldName;
        const entity = (0, get_entity_adapter_from_node_1.getEntityAdapterFromNode)(node, context);
        if (!(0, is_concrete_entity_1.isConcreteEntity)(entity)) {
            throw new Error("Expected authorization rule to be applied on a concrete entity");
        }
        const factory = new QueryASTFactory_1.QueryASTFactory(context.schemaModel);
        const queryASTEnv = new QueryASTContext_1.QueryASTEnv();
        const queryASTContext = new QueryASTContext_1.QueryASTContext({
            target: matchNode,
            env: queryASTEnv,
            neo4jGraphQLContext: context,
        });
        if (fieldName) {
            const attributeAdapter = entity.attributes.get(fieldName);
            if (!attributeAdapter) {
                throw new Error("Couldn't match attribute");
            }
            const attributesFilters = factory.authorizationFactory.createAuthValidateRule({
                authAnnotation: attributeAdapter.annotations.authorization,
                entity,
                operations,
                context,
                when: "AFTER",
                conditionForEvaluation,
            });
            if (attributesFilters) {
                const fieldPredicate = attributesFilters.getPredicate(queryASTContext);
                const fieldSelection = attributesFilters.getSelection(queryASTContext);
                const fieldSubqueries = attributesFilters.getSubqueries(queryASTContext);
                const preComputedSubqueries = [...(0, utils_1.asArray)(fieldSelection), ...(0, utils_1.asArray)(fieldSubqueries)];
                if (preComputedSubqueries) {
                    subqueries = cypher_builder_1.default.utils.concat(subqueries, ...preComputedSubqueries);
                }
                if (fieldPredicate) {
                    predicates.push(fieldPredicate);
                }
            }
        }
    }
    if (!predicates.length) {
        return;
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
//# sourceMappingURL=create-authorization-after-predicate.js.map