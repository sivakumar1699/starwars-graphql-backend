"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthorizationBeforePredicate = createAuthorizationBeforePredicate;
exports.createAuthorizationBeforePredicateField = createAuthorizationBeforePredicateField;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const get_entity_adapter_from_node_1 = require("../../utils/get-entity-adapter-from-node");
const utils_1 = require("../../utils/utils");
const QueryASTContext_1 = require("../queryAST/ast/QueryASTContext");
const QueryASTFactory_1 = require("../queryAST/factory/QueryASTFactory");
const is_concrete_entity_1 = require("../queryAST/utils/is-concrete-entity");
const wrap_subquery_in_call_1 = require("../queryAST/utils/wrap-subquery-in-call");
function createAuthorizationBeforePredicate({ context, nodes, operations, }) {
    const predicates = [];
    let subqueries;
    for (const nodeEntry of nodes) {
        const node = nodeEntry.node;
        const matchNode = nodeEntry.variable;
        const entity = (0, get_entity_adapter_from_node_1.getEntityAdapterFromNode)(node, context);
        if (!(0, is_concrete_entity_1.isConcreteEntity)(entity)) {
            throw new Error("Expected authorization rule to be applied on a concrete entity");
        }
        const factory = new QueryASTFactory_1.QueryASTFactory(context.schemaModel);
        const queryASTEnv = new QueryASTContext_1.QueryASTEnv();
        const queryASTContext = new QueryASTContext_1.QueryASTContext({
            target: matchNode,
            env: queryASTEnv,
            neo4jGraphQLContext: context,
        });
        const authorizationRules = factory.authorizationFactory.getAuthFilters({
            entity,
            operations,
            context,
        });
        authorizationRules.forEach((filter) => {
            const nodeRawSubqueries = filter?.getSubqueries(queryASTContext);
            const nodeSubqueries = (0, utils_1.filterTruthy)(nodeRawSubqueries).map((sq) => (0, wrap_subquery_in_call_1.wrapSubqueryInCall)(sq, matchNode));
            const nodePredicate = filter?.getPredicate(queryASTContext);
            if (nodePredicate) {
                predicates.push(nodePredicate);
            }
            const extraSelections = filter?.getSelection(queryASTContext);
            const preComputedSubqueries = [...extraSelections, ...nodeSubqueries];
            if (preComputedSubqueries) {
                subqueries = cypher_builder_1.default.utils.concat(subqueries, ...preComputedSubqueries);
            }
        });
    }
    if (!predicates.length) {
        return;
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
function createAuthorizationBeforePredicateField({ context, nodes, operations, }) {
    const predicates = [];
    let subqueries;
    for (const nodeEntry of nodes) {
        const node = nodeEntry.node;
        const matchNode = nodeEntry.variable;
        const fieldName = nodeEntry.fieldName;
        const entity = (0, get_entity_adapter_from_node_1.getEntityAdapterFromNode)(node, context);
        if (!(0, is_concrete_entity_1.isConcreteEntity)(entity)) {
            throw new Error("Expected authorization rule to be applied on a concrete entity");
        }
        const factory = new QueryASTFactory_1.QueryASTFactory(context.schemaModel);
        const queryASTEnv = new QueryASTContext_1.QueryASTEnv();
        const queryASTContext = new QueryASTContext_1.QueryASTContext({
            target: matchNode,
            env: queryASTEnv,
            neo4jGraphQLContext: context,
        });
        if (fieldName) {
            const attributeAdapter = entity.attributes.get(fieldName);
            if (!attributeAdapter) {
                throw new Error("Couldn't match attribute");
            }
            const attributesFilters = factory.authorizationFactory.createAuthFilterRule({
                authAnnotation: attributeAdapter.annotations.authorization,
                entity,
                operations,
                context,
            });
            const attributesValidate = factory.authorizationFactory.createAuthValidateRule({
                authAnnotation: attributeAdapter.annotations.authorization,
                entity,
                operations,
                context,
                when: "BEFORE",
            });
            (0, utils_1.filterTruthy)([attributesFilters, attributesValidate]).forEach((filter) => {
                const fieldPredicate = filter.getPredicate(queryASTContext);
                const fieldSelection = filter.getSelection(queryASTContext);
                const fieldSubqueries = filter.getSubqueries(queryASTContext);
                const preComputedSubqueries = [...fieldSelection, ...fieldSubqueries];
                if (preComputedSubqueries) {
                    subqueries = cypher_builder_1.default.utils.concat(subqueries, ...preComputedSubqueries);
                }
                if (fieldPredicate)
                    predicates.push(fieldPredicate);
            });
        }
    }
    if (!predicates.length) {
        return;
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
//# sourceMappingURL=create-authorization-before-predicate.js.map