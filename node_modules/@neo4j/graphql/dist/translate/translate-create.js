"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = translateCreate;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const debug_1 = __importDefault(require("debug"));
const CallbackBucket_1 = require("../classes/CallbackBucket");
const constants_1 = require("../constants");
const compile_cypher_1 = require("../utils/compile-cypher");
const utils_1 = require("../utils/utils");
const create_create_and_params_1 = __importDefault(require("./create-create-and-params"));
const QueryASTContext_1 = require("./queryAST/ast/QueryASTContext");
const QueryASTFactory_1 = require("./queryAST/factory/QueryASTFactory");
const is_unwind_create_supported_1 = require("./queryAST/factory/parsers/is-unwind-create-supported");
const unwind_create_1 = __importDefault(require("./unwind-create"));
const build_clause_1 = require("./utils/build-clause");
const get_authorization_statements_1 = require("./utils/get-authorization-statements");
const debug = (0, debug_1.default)(constants_1.DEBUG_TRANSLATE);
async function translateCreate({ context, node, }) {
    const { resolveTree } = context;
    const mutationInputs = resolveTree.args.input;
    const entityAdapter = context.schemaModel.getConcreteEntityAdapter(node.name);
    if (!entityAdapter) {
        throw new Error(`Transpilation error: ${node.name} is not a concrete entity`);
    }
    const { isSupported, reason } = (0, is_unwind_create_supported_1.isUnwindCreateSupported)(entityAdapter, (0, utils_1.asArray)(mutationInputs), context);
    if (isSupported) {
        return (0, unwind_create_1.default)({ context, entityAdapter });
    }
    debug(`Unwind create optimization not supported: ${reason}`);
    const projectionWith = [];
    const callbackBucket = new CallbackBucket_1.CallbackBucket(context);
    const metaNames = [];
    // TODO: after the createCreateAndParams refactor, remove varNameStrs and only use Cypher Variables
    const varNameStrs = mutationInputs.map((_, i) => `this${i}`);
    const varNameVariables = varNameStrs.map((varName) => new cypher_builder_1.default.NamedNode(varName));
    const { createStrs, params } = mutationInputs.reduce((res, input, index) => {
        const varName = varNameStrs[index];
        if (!varName) {
            throw new Error("Expected varName to be defined");
        }
        const create = [`CALL {`];
        const withVars = [varName];
        projectionWith.push(varName);
        const { create: nestedCreate, params, authorizationPredicates, authorizationSubqueries, } = (0, create_create_and_params_1.default)({
            input,
            node,
            context,
            varName,
            withVars,
            topLevelNodeVariable: varName,
            callbackBucket,
        });
        create.push(nestedCreate);
        create.push(...(0, get_authorization_statements_1.getAuthorizationStatements)(authorizationPredicates, authorizationSubqueries));
        create.push(`RETURN ${varName}`);
        create.push(`}`);
        res.createStrs.push(create.join("\n"));
        res.params = { ...res.params, ...params };
        return res;
    }, { createStrs: [], params: {}, withVars: [] });
    if (metaNames.length > 0) {
        projectionWith.push(`${metaNames.join(" + ")} AS meta`);
    }
    const queryAST = new QueryASTFactory_1.QueryASTFactory(context.schemaModel).createQueryAST({
        resolveTree,
        entityAdapter,
        context,
    });
    const queryASTEnv = new QueryASTContext_1.QueryASTEnv();
    const projectedVariables = [];
    /**
     * Currently, the create projections are resolved separately for each input,
     * the following block reuses the same ReadOperation for each of the variable names generated during the create operations.
     **/
    const projectionClause = cypher_builder_1.default.utils.concat(...(0, utils_1.filterTruthy)(varNameVariables.map((varName) => {
        const queryASTContext = new QueryASTContext_1.QueryASTContext({
            target: varName,
            env: queryASTEnv,
            neo4jGraphQLContext: context,
        });
        debug(queryAST.print());
        const queryASTResult = queryAST.transpile(queryASTContext);
        if (queryASTResult.clauses.length) {
            projectedVariables.push(queryASTResult.projectionExpr);
            const clause = cypher_builder_1.default.utils.concat(...queryASTResult.clauses);
            return new cypher_builder_1.default.Call(clause).importWith(varName);
        }
    })));
    const returnStatement = getReturnStatement(projectedVariables);
    const createQuery = new cypher_builder_1.default.Raw((env) => {
        const cypher = (0, utils_1.filterTruthy)([
            `${createStrs.join("\n")}`,
            (0, compile_cypher_1.compileCypherIfExists)(projectionClause, env),
            (0, compile_cypher_1.compileCypherIfExists)(returnStatement, env),
        ])
            .filter(Boolean)
            .join("\n");
        return [
            cypher,
            {
                ...params,
            },
        ];
    });
    const createQueryCypher = (0, build_clause_1.buildClause)(createQuery, { context, prefix: "create_" });
    const { cypher, params: resolvedCallbacks } = await callbackBucket.resolveCallbacksAndFilterCypher({
        cypher: createQueryCypher.cypher,
    });
    const result = {
        cypher,
        params: {
            ...createQueryCypher.params,
            resolvedCallbacks,
        },
    };
    return result;
}
function getReturnStatement(projectedVariables) {
    const ret = new cypher_builder_1.default.Return();
    if (projectedVariables.length) {
        ret.addColumns([new cypher_builder_1.default.List(projectedVariables), new cypher_builder_1.default.NamedVariable("data")]);
    }
    if (!projectedVariables.length) {
        ret.addColumns(new cypher_builder_1.default.Literal("Query cannot conclude with CALL"));
    }
    return ret;
}
//# sourceMappingURL=translate-create.js.map