"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const Scalars = __importStar(require("../graphql/scalars"));
const aggregation_types_mapper_1 = require("./aggregations/aggregation-types-mapper");
const fulltext_1 = require("./augment/fulltext");
const ensure_non_empty_input_1 = require("./ensure-non-empty-input");
const get_custom_resolvers_1 = __importDefault(require("./get-custom-resolvers"));
const get_obj_field_meta_1 = require("./get-obj-field-meta");
const cypher_1 = require("./resolvers/field/cypher");
const create_1 = require("./resolvers/mutation/create");
const delete_1 = require("./resolvers/mutation/delete");
const update_1 = require("./resolvers/mutation/update");
const read_1 = require("./resolvers/query/read");
const root_connection_1 = require("./resolvers/query/root-connection");
const to_compose_1 = require("./to-compose");
const constants_1 = require("../constants");
const CreateInfo_1 = require("../graphql/objects/CreateInfo");
const DeleteInfo_1 = require("../graphql/objects/DeleteInfo");
const PageInfo_1 = require("../graphql/objects/PageInfo");
const UpdateInfo_1 = require("../graphql/objects/UpdateInfo");
const OperationAdapter_1 = require("../schema-model/OperationAdapter");
const ConcreteEntity_1 = require("../schema-model/entity/ConcreteEntity");
const InterfaceEntity_1 = require("../schema-model/entity/InterfaceEntity");
const UnionEntity_1 = require("../schema-model/entity/UnionEntity");
const ConcreteEntityAdapter_1 = require("../schema-model/entity/model-adapters/ConcreteEntityAdapter");
const InterfaceEntityAdapter_1 = require("../schema-model/entity/model-adapters/InterfaceEntityAdapter");
const UnionEntityAdapter_1 = require("../schema-model/entity/model-adapters/UnionEntityAdapter");
const definition_collection_1 = require("../schema-model/parser/definition-collection");
const RelationshipDeclarationAdapter_1 = require("../schema-model/relationship/model-adapters/RelationshipDeclarationAdapter");
const utils_1 = require("../utils/utils");
const vector_1 = require("./augment/vector");
const create_connection_fields_1 = require("./create-connection-fields");
const create_global_nodes_1 = require("./create-global-nodes");
const create_relationship_fields_1 = require("./create-relationship-fields/create-relationship-fields");
const AugmentedSchemaGenerator_1 = require("./generation/AugmentedSchemaGenerator");
const aggregate_types_1 = require("./generation/aggregate-types");
const create_input_1 = require("./generation/create-input");
const interface_type_1 = require("./generation/interface-type");
const object_type_1 = require("./generation/object-type");
const response_types_1 = require("./generation/response-types");
const update_input_1 = require("./generation/update-input");
const where_input_1 = require("./generation/where-input");
const get_nodes_1 = __importDefault(require("./get-nodes"));
const get_resolve_and_subscription_methods_1 = require("./get-resolve-and-subscription-methods");
const filter_interface_types_1 = require("./make-augmented-schema/filter-interface-types");
const user_defined_directives_1 = require("./make-augmented-schema/user-defined-directives");
const generate_subscription_types_1 = require("./subscriptions/generate-subscription-types");
function definitionNodeHasName(x) {
    return "name" in x;
}
function makeAugmentedSchema({ document, features, userCustomResolvers, subgraph, schemaModel, complexityEstimatorHelper, }) {
    const composer = new graphql_compose_1.SchemaComposer();
    const callbacks = features?.populatedBy?.callbacks;
    let relationships = [];
    //TODO: definition collection is being used to harmonize schema generation with schema model,
    //however make augmented schema inner methods are still accepting arrays as they were defined by the previous getDefinitionNodes
    const definitionCollection = (0, definition_collection_1.getDefinitionCollection)(document);
    const { interfaceTypes, scalarTypes, userDefinedObjectTypes, enumTypes, unionTypes, inputTypes, directives, schemaExtensions, } = definitionCollection;
    const customResolvers = (0, get_custom_resolvers_1.default)(document);
    const schemaGenerator = new AugmentedSchemaGenerator_1.AugmentedSchemaGenerator(schemaModel, definitionCollection, [customResolvers.customQuery, customResolvers.customMutation, customResolvers.customSubscription].filter((x) => Boolean(x)));
    const generatorComposer = schemaGenerator.generate();
    composer.merge(generatorComposer);
    // Generates the filters for enums, which are reused
    Array.from(enumTypes.values()).forEach((enumType) => {
        composer.createInputTC({
            name: `${enumType.name.value}EnumScalarFilters`,
            description: `${enumType.name.value} filters`,
            fields: {
                eq: {
                    type: enumType.name.value,
                },
                in: { type: `[${enumType.name.value}!]` },
            },
        });
        composer.createInputTC({
            name: `${enumType.name.value}ListEnumScalarFilters`,
            description: `${enumType.name.value} filters`,
            fields: {
                eq: {
                    type: `[${enumType.name.value}!]`,
                },
                includes: {
                    type: enumType.name.value,
                },
            },
        });
    });
    // Generates the mutations for enums, which are reused
    Array.from(enumTypes.values()).forEach((enumType) => {
        composer.createInputTC({
            name: `${enumType.name.value}EnumScalarMutations`,
            description: `${enumType.name.value} mutations`,
            fields: {
                set: { type: enumType.name.value },
            },
        });
        composer.createInputTC({
            name: `${enumType.name.value}ListEnumScalarMutations`,
            description: `Mutations for a list for ${enumType.name.value}`,
            fields: {
                set: { type: `[${enumType.name.value}!]!` },
                push: { type: `[${enumType.name.value}!]!` },
                pop: { type: enumType.name.value },
            },
        });
    });
    // Generates the filters for custom scalars
    Array.from(scalarTypes.values()).forEach((enumType) => {
        composer.createInputTC({
            name: `${enumType.name.value}ScalarFilters`,
            description: `${enumType.name.value} filters`,
            fields: {
                eq: {
                    type: enumType.name.value,
                },
                in: { type: `[${enumType.name.value}!]` },
            },
        });
        composer.createInputTC({
            name: `${enumType.name.value}ListScalarFilters`,
            description: `${enumType.name.value} filters`,
            fields: {
                eq: {
                    type: `[${enumType.name.value}!]`,
                },
                includes: {
                    type: enumType.name.value,
                },
            },
        });
    });
    // Generates the mutations for custom scalars
    Array.from(scalarTypes.values()).forEach((enumType) => {
        composer.createInputTC({
            name: `${enumType.name.value}ScalarMutations`,
            description: `${enumType.name.value} filters`,
            fields: {
                set: { type: enumType.name.value },
            },
        });
        composer.createInputTC({
            name: `${enumType.name.value}ListScalarMutations`,
            description: `Mutations for a list for ${enumType.name.value}`,
            fields: {
                set: { type: `[${enumType.name.value}!]!` },
                push: { type: `[${enumType.name.value}!]!` },
                pop: { type: enumType.name.value },
            },
        });
    });
    // TODO: move these to SchemaGenerator once the other types are moved (in the meantime references to object types are causing errors because they are not present in the generated schema)
    const pipedDefs = [
        ...userDefinedObjectTypes.values(),
        ...enumTypes.values(),
        ...scalarTypes.values(),
        ...inputTypes.values(),
        ...unionTypes.values(),
        ...directives.values(),
        ...(0, utils_1.filterTruthy)([
            customResolvers.customQuery,
            customResolvers.customMutation,
            customResolvers.customSubscription,
        ]),
    ];
    if (pipedDefs.length) {
        composer.addTypeDefs((0, graphql_1.print)({ kind: graphql_1.Kind.DOCUMENT, definitions: pipedDefs }));
    }
    // TODO: ideally move these in getSubgraphSchema()
    if (subgraph) {
        const shareable = subgraph.getFullyQualifiedDirectiveName(constants_1.SHAREABLE);
        [CreateInfo_1.CreateInfo.name, UpdateInfo_1.UpdateInfo.name, DeleteInfo_1.DeleteInfo.name, PageInfo_1.PageInfo.name].forEach((typeName) => {
            const typeComposer = composer.getOTC(typeName);
            typeComposer.setDirectiveByName(shareable);
        });
    }
    const aggregationTypesMapper = new aggregation_types_mapper_1.AggregationTypesMapper(composer, subgraph);
    const getNodesResult = (0, get_nodes_1.default)(definitionCollection, { callbacks, userCustomResolvers });
    const { nodes, interfaceRelationshipNames } = getNodesResult;
    const hasGlobalNodes = (0, create_global_nodes_1.addGlobalNodeFields)(nodes, composer, schemaModel.concreteEntities);
    const { filteredInterfaceTypes } = (0, filter_interface_types_1.filterInterfaceTypes)(interfaceTypes.values(), interfaceRelationshipNames);
    const { userDefinedFieldDirectivesForNode, userDefinedDirectivesForNode, propagatedDirectivesForNode, userDefinedDirectivesForInterface, userDefinedDirectivesForUnion, } = (0, user_defined_directives_1.getUserDefinedDirectives)(definitionCollection);
    /**
     * TODO [translation-layer-compatibility]
     * keeping this `relationshipFields` scaffold for backwards compatibility on translation layer
     * actual functional logic is in schemaModel.concreteEntities.forEach
     */
    const relationshipFields = new Map();
    for (const relationship of definitionCollection.relationshipProperties.values()) {
        const relFields = (0, get_obj_field_meta_1.getObjFieldMeta)({
            interfaces: filteredInterfaceTypes,
            definitionCollection,
            obj: relationship,
            callbacks,
        });
        relationshipFields.set(relationship.name.value, relFields);
    }
    // this is the new "functional" way for the above forEach
    // helper to only create relationshipProperties Interface types once, even if multiple relationships reference it
    const seenRelationshipPropertiesTypes = new Set();
    schemaModel.entities.forEach((entity) => {
        if (entity instanceof UnionEntity_1.UnionEntity) {
            const unionEntityAdapter = new UnionEntityAdapter_1.UnionEntityAdapter(entity);
            (0, where_input_1.withWhereInputType)({
                entityAdapter: unionEntityAdapter,
                userDefinedFieldDirectives: new Map(),
                features,
                composer,
            });
            // strip-out the schema config directives from the union type
            const def = composer.getUTC(unionEntityAdapter.name);
            def.setDirectives((0, to_compose_1.graphqlDirectivesToCompose)(userDefinedDirectivesForUnion.get(unionEntityAdapter.name) || []));
            const hasImplementedEntities = unionEntityAdapter.concreteEntities.length > 0;
            if (unionEntityAdapter.isReadable(schemaModel) && hasImplementedEntities) {
                complexityEstimatorHelper.registerField("Query", unionEntityAdapter.operations.rootTypeFieldNames.read);
                composer.Query.addFields({
                    [unionEntityAdapter.operations.rootTypeFieldNames.read]: (0, read_1.findResolver)({
                        entityAdapter: unionEntityAdapter,
                        composer,
                        isLimitRequired: features?.limitRequired,
                    }),
                });
            }
            return;
        }
        if (entity instanceof InterfaceEntity_1.InterfaceEntity) {
            const interfaceEntityAdapter = new InterfaceEntityAdapter_1.InterfaceEntityAdapter(entity);
            const userDefinedInterfaceDirectives = userDefinedDirectivesForInterface.get(entity.name) || [];
            generateInterfaceObjectType({
                composer,
                interfaceEntityAdapter,
                subgraph,
                userDefinedInterfaceDirectives,
                userDefinedFieldDirectivesForNode,
                propagatedDirectivesForNode,
                aggregationTypesMapper,
                seenRelationshipPropertiesTypes,
                features,
                complexityEstimatorHelper,
                schemaModel,
            });
            const connectionFields = (0, create_connection_fields_1.createConnectionFields)({
                entityAdapter: interfaceEntityAdapter,
                relationshipFields,
            });
            relationships = [...relationships, ...connectionFields];
            return;
        }
        if (entity instanceof ConcreteEntity_1.ConcreteEntity) {
            /**
             * TODO [translation-layer-compatibility]
             * need the node for fulltext translation
             */
            const node = nodes.find((n) => n.name === entity.name);
            if (!node) {
                throw new Error(`Node not found with the name ${entity.name}`);
            }
            const concreteEntityAdapter = new ConcreteEntityAdapter_1.ConcreteEntityAdapter(entity);
            const userDefinedFieldDirectives = userDefinedFieldDirectivesForNode.get(concreteEntityAdapter.name);
            if (!userDefinedFieldDirectives) {
                throw new Error(`User defined field directives not found for ${concreteEntityAdapter.name}`);
            }
            const propagatedDirectives = propagatedDirectivesForNode.get(entity.name) || [];
            const userDefinedObjectDirectives = (userDefinedDirectivesForNode.get(entity.name) || []).concat(propagatedDirectives);
            generateObjectType({
                composer,
                concreteEntityAdapter,
                subgraph,
                features,
                userDefinedObjectDirectives,
                userDefinedFieldDirectives,
                propagatedDirectives,
                aggregationTypesMapper,
                node,
                seenRelationshipPropertiesTypes,
                userDefinedDirectivesForNode,
                userDefinedFieldDirectivesForNode,
                complexityEstimatorHelper,
                schemaModel,
            });
            const connectionFields = (0, create_connection_fields_1.createConnectionFields)({
                entityAdapter: concreteEntityAdapter,
                relationshipFields,
            });
            relationships = [...relationships, ...connectionFields];
            return;
        }
    });
    if (nodes.length) {
        (0, generate_subscription_types_1.generateSubscriptionTypes)({
            schemaComposer: composer,
            schemaModel,
            userDefinedFieldDirectivesForNode,
            features,
        });
    }
    ["Query", "Mutation"].forEach((type) => {
        const objectComposer = composer[type];
        const operation = schemaModel.operations[type];
        if (!operation) {
            return;
        }
        const operationAdapter = new OperationAdapter_1.OperationAdapter(operation);
        const userDefinedFieldDirectives = userDefinedFieldDirectivesForNode.get(type);
        for (const attributeAdapter of operationAdapter.attributes.values()) {
            /**
             * TODO [translation-layer-compatibility]
             * needed for compatibility with translation layer
             */
            const objectFields = (0, get_obj_field_meta_1.getObjFieldMeta)({
                obj: customResolvers[`customCypher${type}`],
                interfaces: filteredInterfaceTypes,
                definitionCollection,
                callbacks,
            });
            const field = objectFields.cypherFields.find((f) => f.fieldName === attributeAdapter.name);
            const customResolver = (0, cypher_1.cypherResolver)({
                field,
                attributeAdapter,
                type: type,
            });
            const composedField = (0, to_compose_1.attributeAdapterToComposeFields)([attributeAdapter], userDefinedFieldDirectives)[attributeAdapter.name];
            objectComposer.addFields({ [attributeAdapter.name]: { ...composedField, ...customResolver } });
        }
        // this is to remove library directives from custom resolvers on root type fields in augmented schema
        for (const attributeAdapter of operationAdapter.userResolvedAttributes.values()) {
            const composedField = (0, to_compose_1.attributeAdapterToComposeFields)([attributeAdapter], userDefinedFieldDirectives)[attributeAdapter.name];
            if (composedField) {
                objectComposer.addFields({ [attributeAdapter.name]: composedField });
            }
        }
    });
    if (!Object.values(composer.Mutation.getFields()).length) {
        composer.delete("Mutation");
    }
    if (!Object.values(composer.Subscription.getFields()).length) {
        composer.delete("Subscription");
    }
    const generatedTypeDefs = composer.toSDL();
    let parsedDoc = (0, graphql_1.parse)(generatedTypeDefs);
    const documentNames = new Set(parsedDoc.definitions.filter(definitionNodeHasName).map((x) => x.name.value));
    const resolveMethods = (0, get_resolve_and_subscription_methods_1.getResolveAndSubscriptionMethods)(composer);
    const generatedResolveMethods = {};
    for (const [key, value] of Object.entries(resolveMethods)) {
        if (documentNames.has(key)) {
            generatedResolveMethods[key] = value;
        }
    }
    const generatedResolvers = {
        ...generatedResolveMethods,
        ...Object.values(Scalars).reduce((res, scalar) => {
            if (generatedTypeDefs.includes(`scalar ${scalar.name}\n`)) {
                res[scalar.name] = scalar;
            }
            return res;
        }, {}),
        ...(hasGlobalNodes ? { Node: { __resolveType: (root) => root.__resolveType } } : {}),
    };
    // TODO: improve this logic so we don't iterate through the entire document for each compositeEntity
    // It is possible to make types "writeonly". In this case adding a resolver for them breaks schema generation.
    schemaModel.compositeEntities.forEach((compositeEntity) => {
        const definitionIsOfTheSameType = (def) => (def.kind === graphql_1.Kind.UNION_TYPE_DEFINITION && compositeEntity instanceof UnionEntity_1.UnionEntity) ||
            (def.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION && compositeEntity instanceof InterfaceEntity_1.InterfaceEntity);
        const shouldGenerateResolver = parsedDoc.definitions.some((def) => {
            if (definitionIsOfTheSameType(def) && def.name.value === compositeEntity.name) {
                return true;
            }
            return false;
        });
        if (shouldGenerateResolver && !generatedResolvers[compositeEntity.name]) {
            generatedResolvers[compositeEntity.name] = {
                __resolveType: (root) => root.__resolveType,
            };
        }
        if (compositeEntity instanceof InterfaceEntity_1.InterfaceEntity) {
            for (const relationshipDeclaration of compositeEntity.relationshipDeclarations.values()) {
                const relationshipDeclarationPropertiesType = new RelationshipDeclarationAdapter_1.RelationshipDeclarationAdapter(relationshipDeclaration).operations.relationshipPropertiesFieldTypename;
                const isPropertiesTypeInSchema = parsedDoc.definitions.some((def) => def["name"]?.value === relationshipDeclarationPropertiesType);
                if (isPropertiesTypeInSchema && !generatedResolvers[relationshipDeclarationPropertiesType]) {
                    generatedResolvers[relationshipDeclarationPropertiesType] = {
                        __resolveType: (root) => root.__resolveType,
                    };
                }
            }
        }
    });
    parsedDoc = {
        ...parsedDoc,
        definitions: getTransformedDefinitionNodesForAugmentedSchema({
            schemaExtensions,
            definitions: parsedDoc.definitions,
            complexityEstimatorHelper,
        }),
    };
    return {
        nodes,
        relationships,
        typeDefs: parsedDoc,
        resolvers: generatedResolvers,
    };
}
function getTransformedDefinitionNodesForAugmentedSchema({ schemaExtensions, definitions, complexityEstimatorHelper, }) {
    const definitionNodes = [];
    // do not propagate Neo4jGraphQL directives on schema extensions
    (0, utils_1.asArray)(schemaExtensions).reduce((acc, schemaExtension) => {
        acc.push({
            kind: schemaExtension.kind,
            loc: schemaExtension.loc,
            operationTypes: schemaExtension.operationTypes,
            directives: schemaExtension.directives?.filter((schemaDirective) => !["query", "mutation", "subscription", "authentication"].includes(schemaDirective.name.value)),
        });
        return acc;
    }, definitionNodes);
    // filter out some definition nodes
    // add FieldEstimator extensions for complexity calculation
    const seen = {};
    definitions.reduce((acc, definition) => {
        if (shouldKeepDefinitionNode(definition, seen)) {
            acc.push(complexityEstimatorHelper.hydrateDefinitionNodeWithComplexityExtensions(definition));
        }
        return acc;
    }, definitionNodes);
    return definitionNodes;
}
function shouldKeepDefinitionNode(definition, seen) {
    // Filter out default scalars, they are not needed and can cause issues
    if (definition.kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION) {
        if ([graphql_1.GraphQLBoolean.name, graphql_1.GraphQLFloat.name, graphql_1.GraphQLID.name, graphql_1.GraphQLInt.name, graphql_1.GraphQLString.name].includes(definition.name.value)) {
            return false;
        }
    }
    if (!("name" in definition)) {
        return true;
    }
    const n = definition.name?.value;
    if (seen[n]) {
        return false;
    }
    seen[n] = n;
    return true;
}
exports.default = makeAugmentedSchema;
// TODO: unify object & interface fns
function generateObjectType({ composer, concreteEntityAdapter, features, subgraph, userDefinedFieldDirectives, userDefinedObjectDirectives, propagatedDirectives, aggregationTypesMapper, node, seenRelationshipPropertiesTypes, userDefinedDirectivesForNode, userDefinedFieldDirectivesForNode, complexityEstimatorHelper, schemaModel, }) {
    (0, where_input_1.withWhereInputType)({
        entityAdapter: concreteEntityAdapter,
        userDefinedFieldDirectives,
        features,
        composer,
    });
    (0, fulltext_1.augmentFulltextSchema)({ composer, concreteEntityAdapter, features, complexityEstimatorHelper });
    (0, vector_1.augmentVectorSchema)({ composer, concreteEntityAdapter, features, complexityEstimatorHelper });
    (0, where_input_1.withUniqueWhereInputType)({ concreteEntityAdapter, composer });
    (0, create_input_1.withCreateInputType)({ entityAdapter: concreteEntityAdapter, userDefinedFieldDirectives, composer });
    (0, update_input_1.withUpdateInputType)({ entityAdapter: concreteEntityAdapter, userDefinedFieldDirectives, composer, features });
    (0, response_types_1.withMutationResponseTypes)({ concreteEntityAdapter, propagatedDirectives, composer });
    const composeNode = (0, object_type_1.withObjectType)({
        entityAdapter: concreteEntityAdapter,
        userDefinedFieldDirectives,
        userDefinedObjectDirectives,
        composer,
    });
    (0, create_relationship_fields_1.createRelationshipFields)({
        entityAdapter: concreteEntityAdapter,
        schemaComposer: composer,
        composeNode,
        subgraph,
        userDefinedFieldDirectives,
        userDefinedDirectivesForNode,
        userDefinedFieldDirectivesForNode,
        features,
        seenRelationshipPropertiesTypes,
        complexityEstimatorHelper,
    });
    (0, ensure_non_empty_input_1.ensureNonEmptyInput)(composer, concreteEntityAdapter.operations.updateInputTypeName);
    (0, ensure_non_empty_input_1.ensureNonEmptyInput)(composer, concreteEntityAdapter.operations.createInputTypeName);
    if (concreteEntityAdapter.isReadable(schemaModel) || concreteEntityAdapter.isAggregable(schemaModel)) {
        complexityEstimatorHelper.registerField("Query", concreteEntityAdapter.operations.rootTypeFieldNames.connection);
        composer.Query.addFields({
            [concreteEntityAdapter.operations.rootTypeFieldNames.connection]: (0, root_connection_1.rootConnectionResolver)({
                composer,
                entityAdapter: concreteEntityAdapter,
                propagatedDirectives,
                isLimitRequired: features?.limitRequired,
                schemaModel,
            }),
        });
    }
    if (concreteEntityAdapter.isReadable(schemaModel)) {
        complexityEstimatorHelper.registerField("Query", concreteEntityAdapter.operations.rootTypeFieldNames.read);
        composer.Query.addFields({
            [concreteEntityAdapter.operations.rootTypeFieldNames.read]: (0, read_1.findResolver)({
                entityAdapter: concreteEntityAdapter,
                composer,
                isLimitRequired: features?.limitRequired,
            }),
        });
        composer.Query.setFieldDirectives(concreteEntityAdapter.operations.rootTypeFieldNames.read, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
        composer.Query.setFieldDirectives(concreteEntityAdapter.operations.rootTypeFieldNames.connection, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
    }
    if (concreteEntityAdapter.isAggregable(schemaModel)) {
        (0, aggregate_types_1.withAggregateSelectionType)({
            entityAdapter: concreteEntityAdapter,
            aggregationTypesMapper,
            propagatedDirectives,
            composer,
            features,
        });
    }
    if (concreteEntityAdapter.isCreatable) {
        composer.Mutation.addFields({
            [concreteEntityAdapter.operations.rootTypeFieldNames.create]: (0, create_1.createResolver)({
                node,
                concreteEntityAdapter,
            }),
        });
        composer.Mutation.setFieldDirectives(concreteEntityAdapter.operations.rootTypeFieldNames.create, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
    }
    if (concreteEntityAdapter.isDeletable) {
        composer.Mutation.addFields({
            [concreteEntityAdapter.operations.rootTypeFieldNames.delete]: (0, delete_1.deleteResolver)({
                composer,
                concreteEntityAdapter,
            }),
        });
        composer.Mutation.setFieldDirectives(concreteEntityAdapter.operations.rootTypeFieldNames.delete, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
    }
    if (concreteEntityAdapter.isUpdatable) {
        composer.Mutation.addFields({
            [concreteEntityAdapter.operations.rootTypeFieldNames.update]: (0, update_1.updateResolver)({
                node,
                concreteEntityAdapter,
            }),
        });
        composer.Mutation.setFieldDirectives(concreteEntityAdapter.operations.rootTypeFieldNames.update, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
    }
}
function generateInterfaceObjectType({ composer, interfaceEntityAdapter, features, subgraph, userDefinedFieldDirectivesForNode, userDefinedInterfaceDirectives, propagatedDirectivesForNode, aggregationTypesMapper, seenRelationshipPropertiesTypes, complexityEstimatorHelper, schemaModel, }) {
    const userDefinedFieldDirectives = userDefinedFieldDirectivesForNode.get(interfaceEntityAdapter.name);
    (0, where_input_1.withWhereInputType)({
        entityAdapter: interfaceEntityAdapter,
        userDefinedFieldDirectives,
        features,
        composer,
    });
    (0, create_input_1.withCreateInputType)({ entityAdapter: interfaceEntityAdapter, userDefinedFieldDirectives, composer });
    (0, update_input_1.withUpdateInputType)({ entityAdapter: interfaceEntityAdapter, userDefinedFieldDirectives, composer, features });
    const composeInterface = (0, interface_type_1.withInterfaceType)({
        interfaceEntityAdapter,
        userDefinedFieldDirectives,
        userDefinedInterfaceDirectives,
        composer,
    });
    (0, create_relationship_fields_1.createRelationshipFields)({
        entityAdapter: interfaceEntityAdapter,
        schemaComposer: composer,
        composeNode: composeInterface,
        subgraph,
        userDefinedFieldDirectives,
        userDefinedDirectivesForNode: new Map(),
        userDefinedFieldDirectivesForNode,
        features,
        seenRelationshipPropertiesTypes,
        complexityEstimatorHelper,
    });
    const hasImplementedEntities = interfaceEntityAdapter.concreteEntities.length > 0;
    if (hasImplementedEntities) {
        const propagatedDirectives = propagatedDirectivesForNode.get(interfaceEntityAdapter.name) || [];
        if (interfaceEntityAdapter.isReadable(schemaModel) || interfaceEntityAdapter.isAggregable(schemaModel)) {
            composer.Query.addFields({
                [interfaceEntityAdapter.operations.rootTypeFieldNames.connection]: (0, root_connection_1.rootConnectionResolver)({
                    composer,
                    entityAdapter: interfaceEntityAdapter,
                    propagatedDirectives,
                    isLimitRequired: features?.limitRequired,
                    schemaModel,
                }),
            });
        }
        if (interfaceEntityAdapter.isReadable(schemaModel)) {
            complexityEstimatorHelper.registerField("Query", interfaceEntityAdapter.operations.rootTypeFieldNames.read);
            composer.Query.addFields({
                [interfaceEntityAdapter.operations.rootTypeFieldNames.read]: (0, read_1.findResolver)({
                    entityAdapter: interfaceEntityAdapter,
                    composer,
                    isLimitRequired: features?.limitRequired,
                }),
            });
            composer.Query.setFieldDirectives(interfaceEntityAdapter.operations.rootTypeFieldNames.read, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
            complexityEstimatorHelper.registerField("Query", interfaceEntityAdapter.operations.rootTypeFieldNames.connection);
            composer.Query.addFields({
                [interfaceEntityAdapter.operations.rootTypeFieldNames.connection]: (0, root_connection_1.rootConnectionResolver)({
                    composer,
                    entityAdapter: interfaceEntityAdapter,
                    propagatedDirectives,
                    isLimitRequired: features?.limitRequired,
                    schemaModel,
                }),
            });
            composer.Query.setFieldDirectives(interfaceEntityAdapter.operations.rootTypeFieldNames.connection, (0, to_compose_1.graphqlDirectivesToCompose)(propagatedDirectives));
        }
        if (interfaceEntityAdapter.isAggregable(schemaModel)) {
            (0, aggregate_types_1.withAggregateSelectionType)({
                entityAdapter: interfaceEntityAdapter,
                aggregationTypesMapper,
                propagatedDirectives,
                composer,
                features,
            });
        }
    }
}
//# sourceMappingURL=make-augmented-schema.js.map