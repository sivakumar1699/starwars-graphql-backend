"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.invalidObjectCombinations = exports.invalidUnionCombinations = exports.invalidInterfaceCombinations = exports.invalidFieldCombinations = void 0;
const library_directives_1 = require("../../../schema-model/library-directives");
exports.invalidFieldCombinations = {
    alias: ["jwtClaim", "cypher", "customResolver", "relationship"],
    authentication: ["jwtClaim", "customResolver", "relationship"],
    authorization: ["jwtClaim", "customResolver", "relationship"],
    coalesce: ["jwtClaim", "relationship"],
    customResolver: [
        "jwtClaim",
        "alias",
        "authentication",
        "authorization",
        "subscriptionsAuthorization",
        "id",
        "relationship",
        "filterable",
        "settable",
        "selectable",
        "sortable",
    ],
    cypher: ["alias", "id", "relationship"],
    default: ["jwtClaim", "populatedBy", "relationship"],
    id: ["jwtClaim", "cypher", "populatedBy", "customResolver", "relationship", "timestamp"],
    populatedBy: ["jwtClaim", "id", "default", "relationship"],
    relationship: [
        "jwtClaim",
        "alias",
        "authentication",
        "authorization",
        "subscriptionsAuthorization",
        "coalesce",
        "cypher",
        "default",
        "id",
        "customResolver",
        "populatedBy",
    ],
    timestamp: ["jwtClaim", "id"],
    jwtClaim: library_directives_1.FIELD_DIRECTIVES.filter((directive) => directive !== "cypher"),
    relayId: ["jwtClaim"],
    subscriptionsAuthorization: ["jwtClaim", "customResolver", "relationship"],
    selectable: ["jwtClaim", "customResolver"],
    settable: ["jwtClaim", "customResolver"],
    filterable: ["jwtClaim", "customResolver"],
    sortable: ["jwtClaim", "customResolver"],
    declareRelationship: ["jwtClaim"],
};
exports.invalidInterfaceCombinations = {
    query: [],
    plural: [],
    limit: [],
};
exports.invalidUnionCombinations = {
    query: [],
    plural: [],
};
exports.invalidObjectCombinations = {
    relationshipProperties: [],
    authentication: [],
    authorization: [],
    deprecated: [],
    fulltext: [],
    // jwt: OBJECT_DIRECTIVES, // This is deliberately commented out. JWT is a special case. We do different validations for jwt.
    mutation: [],
    node: [],
    plural: [],
    query: [],
    shareable: [],
    subscription: [],
    subscriptionsAuthorization: [],
    limit: [],
};
//# sourceMappingURL=invalid-directive-combinations.js.map