"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidListInNodeType = ValidListInNodeType;
const graphql_1 = require("graphql");
const directives_1 = require("../../../../graphql/directives");
const document_validation_error_1 = require("../utils/document-validation-error");
const utils_1 = require("../utils/utils");
/**
 * Validates that list types used in type annotated with the node directive are supported by Neo4j
 **/
function ValidListInNodeType(context) {
    return {
        ObjectTypeDefinition(objectTypeDefinitionNode, _key, _parent) {
            const { directives } = objectTypeDefinitionNode;
            const nodeUsage = directives?.find((directive) => directive.name.value === directives_1.nodeDirective.name);
            const relationshipPropertiesUsage = directives?.find((directive) => directive.name.value === directives_1.relationshipPropertiesDirective.name);
            if (!directives) {
                return; // Skip when no directives are present
            }
            if (!nodeUsage && !relationshipPropertiesUsage) {
                return; // Skip if is the type is neither annotated with node nor relationshipProperties
            }
            objectTypeDefinitionNode.fields?.forEach((fieldDefinitionNode) => {
                const { type, directives } = fieldDefinitionNode;
                if (directives &&
                    directives.some((directive) => directive.name.value === directives_1.cypherDirective.name ||
                        directive.name.value === directives_1.relationshipDirective.name)) {
                    return; // Skip cypher fields and relationship fields, relationship fields have their own validation
                }
                const { isValid, errorMsg, errorPath } = (0, document_validation_error_1.assertValid)(() => {
                    const typePath = getTypePath(type);
                    if (typePath.includes(graphql_1.Kind.LIST_TYPE)) {
                        const wrappedType = (0, utils_1.getInnerTypeName)(type);
                        const validTypePaths = [
                            [graphql_1.Kind.LIST_TYPE, graphql_1.Kind.NON_NULL_TYPE, wrappedType],
                            [graphql_1.Kind.NON_NULL_TYPE, graphql_1.Kind.LIST_TYPE, graphql_1.Kind.NON_NULL_TYPE, wrappedType],
                        ];
                        if (!findTypePathInTypePaths(typePath, validTypePaths)) {
                            const typeStr = (0, utils_1.getPrettyName)(type);
                            const directiveName = (nodeUsage ?? relationshipPropertiesUsage)?.name?.value;
                            throw new document_validation_error_1.DocumentValidationError(`List of nullable elements are not supported in "@${directiveName}" types. Found: ${typeStr}`, []);
                        }
                    }
                });
                if (!isValid) {
                    context.reportError((0, document_validation_error_1.createGraphQLError)({
                        nodes: [fieldDefinitionNode],
                        path: [objectTypeDefinitionNode.name.value, fieldDefinitionNode.name.value, ...errorPath],
                        errorMsg,
                    }));
                }
            });
        },
    };
}
function getTypePath(typeNode, currentPath = []) {
    if (typeNode.kind === graphql_1.Kind.NON_NULL_TYPE || typeNode.kind === graphql_1.Kind.LIST_TYPE) {
        return getTypePath(typeNode.type, [...currentPath, typeNode.kind]);
    }
    return [...currentPath, typeNode.name.value];
}
function findTypePathInTypePaths(typePathToFind, typePaths) {
    const typePathString = typePathToFind.join();
    return typePaths.some((typePath) => typePathString === typePath.join());
}
//# sourceMappingURL=valid-list-in-node-type.js.map