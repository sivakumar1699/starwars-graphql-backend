"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertArgumentHasSameTypeAsField = assertArgumentHasSameTypeAsField;
const graphql_1 = require("graphql");
const constants_1 = require("../../../../constants");
const scalars_1 = require("../../../../graphql/scalars");
const LocalTime_1 = require("../../../../graphql/scalars/LocalTime");
const Time_1 = require("../../../../graphql/scalars/Time");
const document_validation_error_1 = require("./document-validation-error");
const utils_1 = require("./utils");
function assertArgumentHasSameTypeAsField({ directiveName, traversedDef, argument, enums, }) {
    const expectedType = (0, utils_1.getInnerTypeName)(traversedDef.type);
    if ((0, utils_1.isArrayType)(traversedDef)) {
        if (argument.value.kind !== graphql_1.Kind.LIST) {
            throw new document_validation_error_1.DocumentValidationError(`@${directiveName}.${argument.name.value} on ${expectedType} list fields must be a list of ${expectedType} values`, [argument.name.value]);
        }
        argument.value.values.forEach((v) => {
            if (!v) {
                // delegate to DirectiveArgumentOfCorrectType rule
                return;
            }
            if (!doTypesMatch(expectedType, v, enums)) {
                throw new document_validation_error_1.DocumentValidationError(`@${directiveName}.${argument.name.value} on ${expectedType} list fields must be a list of ${expectedType} values`, [argument.name.value]);
            }
        });
    }
    else {
        if (!doTypesMatch(expectedType, argument.value, enums)) {
            throw new document_validation_error_1.DocumentValidationError(`@${directiveName}.${argument.name.value} on ${expectedType} fields must be of type ${expectedType}`, [argument.name.value]);
        }
    }
}
function doTypesMatch(expectedType, argumentValueType, enums) {
    if (expectedType === graphql_1.GraphQLID.name) {
        return Boolean((0, utils_1.fromValueKind)(argumentValueType, enums, expectedType) === graphql_1.GraphQLString.name.toLowerCase());
    }
    if (expectedType === scalars_1.GraphQLBigInt.name) {
        const kind = (0, utils_1.fromValueKind)(argumentValueType, enums, expectedType);
        return Boolean(kind == graphql_1.GraphQLInt.name.toLowerCase() || kind == graphql_1.GraphQLString.name.toLowerCase());
    }
    if (expectedType === graphql_1.GraphQLFloat.name) {
        const kind = (0, utils_1.fromValueKind)(argumentValueType, enums, expectedType)?.toLowerCase();
        return Boolean(kind == graphql_1.GraphQLInt.name.toLowerCase() || kind == graphql_1.GraphQLFloat.name.toLowerCase());
    }
    if ([scalars_1.GraphQLDateTime.name, scalars_1.GraphQLLocalDateTime.name, scalars_1.GraphQLDate.name].includes(expectedType)) {
        return isValidDateTime(argumentValueType);
    }
    if (expectedType === scalars_1.GraphQLTime.name) {
        return isValidTime(argumentValueType);
    }
    if (expectedType === scalars_1.GraphQLLocalTime.name) {
        return isValidLocalTime(argumentValueType);
    }
    // TODO: Spatial types and some of the temporal types values are not yet validated.
    if ((0, constants_1.isSpatial)(expectedType) || (0, constants_1.isTemporal)(expectedType)) {
        return true;
    }
    return (0, utils_1.fromValueKind)(argumentValueType, enums, expectedType)?.toLowerCase() === expectedType.toLowerCase();
}
// TODO: isValidTime and isValidLocalTime are as they were in the original `@default` validation rules,
// this is an improvement compared to the previous implementation as initially it was tested only for the default directive,
// but it can be improved further without using the try-catch,
function isValidTime(valueNode) {
    if (valueNode.kind !== graphql_1.Kind.STRING) {
        return false;
    }
    try {
        (0, Time_1.validateTime)(valueNode.value);
    }
    catch {
        return false;
    }
    return true;
}
function isValidLocalTime(valueNode) {
    if (valueNode.kind !== graphql_1.Kind.STRING) {
        return false;
    }
    try {
        (0, LocalTime_1.parseLocalTime)(valueNode.value);
    }
    catch {
        return false;
    }
    return true;
}
function isValidDateTime(valueNode) {
    if (valueNode.kind !== graphql_1.Kind.STRING) {
        return false;
    }
    return !Number.isNaN(Date.parse(valueNode.value));
}
//# sourceMappingURL=same-type-argument-as-field.js.map