"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Neo4jValidationContext = void 0;
const graphql_1 = require("graphql");
const ValidationContext_1 = require("graphql/validation/ValidationContext");
class Neo4jValidationContext extends ValidationContext_1.SDLValidationContext {
    constructor(ast, schema, onError, callbacks) {
        super(ast, schema, onError);
        this.callbacks = callbacks;
        this.typeMapWithExtensions = buildTypeMapWithExtensions(ast.definitions);
        this.interfacesMap = buildInterfacesMap(ast.definitions, this.typeMapWithExtensions);
    }
}
exports.Neo4jValidationContext = Neo4jValidationContext;
// build a type map to access specific types and their extensions
function buildTypeMapWithExtensions(definitions) {
    return definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION ||
            def.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION ||
            def.kind === graphql_1.Kind.UNION_TYPE_DEFINITION ||
            def.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION ||
            def.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ||
            def.kind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION ||
            def.kind === graphql_1.Kind.UNION_TYPE_EXTENSION) {
            const typeName = def.name.value;
            if (!acc[typeName]) {
                acc[typeName] = { extensions: [], definition: undefined };
            }
            if (def.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ||
                def.kind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION ||
                def.kind === graphql_1.Kind.UNION_TYPE_EXTENSION) {
                if (acc[typeName].extensions) {
                    acc[typeName].extensions.push(def);
                }
                else {
                    acc[typeName].extensions = [def];
                }
            }
            else {
                acc[typeName].definition = def;
            }
        }
        return acc;
    }, {});
}
function buildInterfacesMap(definitions, typeMapWithExtensions) {
    return definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || def.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
            const typeName = def.name.value;
            for (const defInterface of def.interfaces ?? []) {
                const interfaceName = defInterface.name.value;
                if (!acc[interfaceName]) {
                    acc[interfaceName] = [];
                }
                const concreteDefinition = typeMapWithExtensions[typeName]?.definition;
                acc[interfaceName].push(concreteDefinition);
            }
        }
        return acc;
    }, {});
}
//# sourceMappingURL=Neo4jValidationContext.js.map