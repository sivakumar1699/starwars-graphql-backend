"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.withVectorWhereInputType = withVectorWhereInputType;
exports.withVectorSortInputType = withVectorSortInputType;
exports.withVectorResultTypeConnection = withVectorResultTypeConnection;
const graphql_1 = require("graphql");
const constants_1 = require("../../constants");
const SortDirection_1 = require("../../graphql/enums/SortDirection");
const FloatWhere_1 = require("../../graphql/input-objects/FloatWhere");
const PageInfo_1 = require("../../graphql/objects/PageInfo");
function withVectorWhereInputType({ composer, concreteEntityAdapter, }) {
    const typeName = concreteEntityAdapter.operations.vectorTypeNames.where;
    if (composer.has(typeName)) {
        return composer.getITC(typeName);
    }
    const whereInput = composer.createInputTC({
        name: typeName,
        description: `The input for filtering a Vector query on an index of ${concreteEntityAdapter.name}`,
        fields: {
            [constants_1.SCORE_FIELD]: FloatWhere_1.FloatWhere.name,
            ["node"]: concreteEntityAdapter.operations.whereInputTypeName,
        },
    });
    return whereInput;
}
function withVectorSortInputType({ composer, concreteEntityAdapter, }) {
    const typeName = concreteEntityAdapter.operations.vectorTypeNames.sort;
    if (composer.has(typeName)) {
        return composer.getITC(typeName);
    }
    const whereInput = composer.createInputTC({
        name: typeName,
        description: `The input for sorting a Vector query on an index of ${concreteEntityAdapter.name}`,
        fields: {
            [constants_1.SCORE_FIELD]: SortDirection_1.SortDirection.name,
            node: concreteEntityAdapter.operations.sortInputTypeName,
        },
    });
    return whereInput;
}
function withVectorResultTypeConnection({ composer, concreteEntityAdapter, }) {
    const typeName = concreteEntityAdapter.operations.vectorTypeNames.connection;
    if (composer.has(typeName)) {
        return composer.getOTC(typeName);
    }
    const edge = composer.createObjectTC({
        name: concreteEntityAdapter.operations.vectorTypeNames.edge,
        fields: {
            cursor: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
            node: `${concreteEntityAdapter.name}!`,
            [constants_1.SCORE_FIELD]: new graphql_1.GraphQLNonNull(graphql_1.GraphQLFloat),
        },
    });
    const connection = composer.createObjectTC({
        name: typeName,
        fields: {
            totalCount: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            pageInfo: new graphql_1.GraphQLNonNull(PageInfo_1.PageInfo),
            edges: edge.NonNull.List.NonNull,
        },
    });
    return connection;
}
//# sourceMappingURL=vector-input.js.map