"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.withUniqueWhereInputType = withUniqueWhereInputType;
exports.addLogicalOperatorsToWhereInputType = addLogicalOperatorsToWhereInputType;
exports.withWhereInputType = withWhereInputType;
exports.withSourceWhereInputType = withSourceWhereInputType;
exports.withConnectWhereFieldInputType = withConnectWhereFieldInputType;
const graphql_1 = require("graphql");
const constants_1 = require("../../constants");
const ConcreteEntityAdapter_1 = require("../../schema-model/entity/model-adapters/ConcreteEntityAdapter");
const InterfaceEntityAdapter_1 = require("../../schema-model/entity/model-adapters/InterfaceEntityAdapter");
const UnionEntityAdapter_1 = require("../../schema-model/entity/model-adapters/UnionEntityAdapter");
const is_union_entity_1 = require("../../translate/queryAST/utils/is-union-entity");
const get_where_fields_1 = require("../get-where-fields");
const aggregate_types_1 = require("./aggregate-types");
const augment_where_input_1 = require("./augment-where-input");
const utils_1 = require("./utils");
function isEmptyObject(obj) {
    return !Object.keys(obj).length;
}
function withUniqueWhereInputType({ concreteEntityAdapter, composer, }) {
    const uniqueWhereFields = {};
    const uniqueWhereInputType = composer.createInputTC({
        name: concreteEntityAdapter.operations.uniqueWhereInputTypeName,
        fields: uniqueWhereFields,
    });
    return uniqueWhereInputType;
}
function addLogicalOperatorsToWhereInputType(type) {
    type.addFields({
        OR: type.NonNull.List,
        AND: type.NonNull.List,
        NOT: type,
    });
}
function withWhereInputType({ entityAdapter, userDefinedFieldDirectives, features, composer, typeName = entityAdapter.operations.whereInputTypeName, returnUndefinedIfEmpty = false, alwaysAllowNesting, ignoreCypherFieldFilters = false, }) {
    if (composer.has(typeName)) {
        return composer.getITC(typeName);
    }
    const whereFields = makeWhereFields({
        entityAdapter,
        userDefinedFieldDirectives,
        features,
        ignoreCypherFieldFilters,
        composer,
    });
    if (returnUndefinedIfEmpty && isEmptyObject(whereFields)) {
        return undefined;
    }
    const whereInputType = composer.createInputTC({
        name: typeName,
        fields: whereFields,
    });
    const allowNesting = alwaysAllowNesting || !(0, is_union_entity_1.isUnionEntity)(entityAdapter);
    if (allowNesting) {
        addLogicalOperatorsToWhereInputType(whereInputType);
    }
    if (entityAdapter instanceof ConcreteEntityAdapter_1.ConcreteEntityAdapter && entityAdapter.isGlobalNode()) {
        whereInputType.addFields({ id: graphql_1.GraphQLID });
    }
    if (entityAdapter instanceof InterfaceEntityAdapter_1.InterfaceEntityAdapter) {
        const enumValues = Object.fromEntries(entityAdapter.concreteEntities.map((concreteEntity) => [
            concreteEntity.name,
            { value: concreteEntity.name },
        ]));
        if (entityAdapter.concreteEntities.length > 0) {
            const interfaceImplementation = composer.createEnumTC({
                name: entityAdapter.operations.implementationEnumTypename,
                values: enumValues,
            });
            whereInputType.addFields({ typename: { type: interfaceImplementation.NonNull.List } });
        }
    }
    return whereInputType;
}
function makeWhereFields({ entityAdapter, userDefinedFieldDirectives, features, ignoreCypherFieldFilters, composer, }) {
    if (entityAdapter instanceof UnionEntityAdapter_1.UnionEntityAdapter) {
        const fields = {};
        for (const concreteEntity of entityAdapter.concreteEntities) {
            fields[concreteEntity.name] = concreteEntity.operations.whereInputTypeName;
        }
        return fields;
    }
    return (0, get_where_fields_1.getWhereFieldsForAttributes)({
        attributes: entityAdapter.whereFields,
        userDefinedFieldDirectives,
        features,
        ignoreCypherFieldFilters,
        composer,
    });
}
function withSourceWhereInputType({ relationshipAdapter, composer, deprecatedDirectives, userDefinedDirectivesOnTargetFields, features, }) {
    const relationshipTarget = relationshipAdapter.target;
    const relationshipSource = relationshipAdapter.source;
    const whereInput = composer.getITC(relationshipSource.operations.whereInputTypeName);
    (0, augment_where_input_1.augmentWhereInputWithRelationshipFilters)({
        whereInput,
        relationshipAdapter,
        deprecatedDirectives,
        composer,
        features,
    });
    // TODO: Current unions are not supported as relationship targets beyond the above fields
    if (relationshipTarget instanceof UnionEntityAdapter_1.UnionEntityAdapter) {
        return;
    }
    if (relationshipAdapter.isFilterableByAggregate()) {
        (0, aggregate_types_1.withConnectionAggregateInputType)({
            relationshipAdapter,
            entityAdapter: relationshipTarget,
            composer: composer,
            userDefinedDirectivesOnTargetFields,
            features,
        });
        if ((0, utils_1.shouldAddDeprecatedFields)(features, "aggregationFiltersOutsideConnection")) {
            const whereAggregateInput = (0, aggregate_types_1.withAggregateInputType)({
                relationshipAdapter,
                entityAdapter: relationshipTarget,
                composer: composer,
                userDefinedDirectivesOnTargetFields,
                features,
            });
            whereInput.addFields({
                [relationshipAdapter.operations.aggregateFieldName]: {
                    type: whereAggregateInput,
                    directives: deprecatedDirectives.length
                        ? deprecatedDirectives
                        : [
                            {
                                name: constants_1.DEPRECATED,
                                args: {
                                    reason: `Aggregate filters are moved inside the ${relationshipAdapter.operations.connectionFieldName} filter, please use { ${relationshipAdapter.operations.connectionFieldName}: { aggregate: {...} } } instead`,
                                },
                            },
                        ],
                },
            });
        }
    }
}
function withConnectWhereFieldInputType(relationshipTarget, composer) {
    const connectWhereName = relationshipTarget.operations.connectWhereInputTypeName;
    if (composer.has(connectWhereName)) {
        return composer.getITC(connectWhereName);
    }
    const connectWhereType = composer.createInputTC({
        name: connectWhereName,
        fields: { node: `${relationshipTarget.operations.whereInputTypeName}!` },
    });
    return connectWhereType;
}
//# sourceMappingURL=where-input.js.map