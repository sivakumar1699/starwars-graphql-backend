import type { PathVariable } from "..";
import { CypherEnvironment } from "../Environment";
import { WithWhere } from "../clauses/mixins/sub-clauses/WithWhere";
import type { LabelExpr } from "../expressions/labels/label-expressions";
import { Variable } from "../references/Variable";
import type { Expr } from "../types";
import { PartialPattern } from "./PartialPattern";
import { PathAssign } from "./PathAssign";
import { PatternElement } from "./PatternElement";
import { QuantifiedPattern, type Quantifier } from "./quantified-patterns/QuantifiedPattern";
/** @group Patterns */
export type NodePatternOptions = {
    labels?: string | string[] | LabelExpr;
    properties?: Record<string, Expr>;
};
/** @group Patterns */
export type RelationshipPatternOptions = {
    type?: string | LabelExpr;
    properties?: Record<string, Expr>;
    direction?: "left" | "right" | "undirected";
    length?: number | "*" | {
        min: number;
        max?: number;
    } | {
        min?: number;
        max: number;
    } | {
        min: number;
        max: number;
    };
};
export type LengthOption = RelationshipPatternOptions["length"];
export interface Pattern extends WithWhere {
}
/** Represents a pattern of a single node or n-relationships to be used in clauses.
 * @see {@link https://neo4j.com/docs/cypher-manual/current/syntax/patterns/ | Cypher Documentation}
 * @group Patterns
 */
export declare class Pattern extends PatternElement {
    private readonly properties;
    private readonly labels;
    protected previous: PartialPattern | undefined;
    constructor(nodeConfig?: NodePatternOptions);
    constructor(node: Variable | undefined, options?: NodePatternOptions);
    related(ref?: Variable, options?: RelationshipPatternOptions): PartialPattern;
    related(ref: RelationshipPatternOptions): PartialPattern;
    /** Adds a quantifier to the pattern such as `{1,3}`, to be used as part of a {@link QuantifiedPath} */
    quantifier(quantifier: Quantifier): QuantifiedPattern;
    assignTo(variable: PathVariable): PathAssign<this>;
    /**
     * @internal
     */
    getCypher(env: CypherEnvironment): string;
    private getLabelsStr;
}
export declare class NestedPattern extends Pattern {
    constructor(nodeVariable?: Variable | NodePatternOptions, options?: NodePatternOptions, previous?: PartialPattern);
    /** Overrides custom string to `Pattern` instead of `NestedPattern`
     * @hidden
     */
    toString(): string;
}
