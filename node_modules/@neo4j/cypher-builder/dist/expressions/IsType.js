"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsType = exports.ListType = exports.CypherTypes = void 0;
exports.isType = isType;
exports.isNotType = isNotType;
const CypherASTNode_1 = require("../CypherASTNode");
const as_array_1 = require("../utils/as-array");
const BaseTypes = {
    ANY: "ANY",
    BOOLEAN: "BOOLEAN",
    DATE: "DATE",
    DURATION: "DURATION",
    FLOAT: "FLOAT",
    INTEGER: "INTEGER",
    LOCAL_DATETIME: "LOCAL DATETIME",
    LOCAL_TIME: "LOCAL_TIME",
    MAP: "MAP",
    NODE: "NODE",
    NOTHING: "NOTHING",
    NULL: "NULL",
    PATH: "PATH",
    POINT: "POINT",
    PROPERTY_VALUE: "PROPERTY VALUE",
    RELATIONSHIP: "RELATIONSHIP",
    STRING: "STRING",
    ZONED_DATETIME: "ZONED DATETIME",
    ZONED_TIME: "ZONED TIME",
    TIMESTAMP_WITHOUT_TIME_ZONE: "TIMESTAMP WITHOUT TIME ZONE",
    TIME_WITHOUT_TIME_ZONE: "TIME WITHOUT TIME ZONE",
    TIMESTAMP_WITH_TIME_ZONE: "TIMESTAMP WITH TIME ZONE",
    TIME_WITH_TIME_ZONE: "TIME WITH TIME ZONE",
};
/**
 * Generates a cypher `LIST<...>` type
 * @example
 * ```cypher
 * LIST<STRING>
 * ```
 */
function list(type) {
    return new ListType((0, as_array_1.asArray)(type));
}
/**
 * Types supported by Neo4j
 * @see {@link https://neo4j.com/docs/cypher-manual/current/values-and-types/property-structural-constructed/#types-synonyms | Cypher Documentation}
 */
exports.CypherTypes = {
    ...BaseTypes,
    list,
};
/**
 * Type predicate expression
 * @group Expressions
 * @see {@link https://neo4j.com/docs/cypher-manual/current/values-and-types/type-predicate/ | Cypher Documentation}
 * @example
 * ```cypher
 * val IS :: INTEGER
 * ```
 */
function isType(expr, type) {
    return new IsType(expr, (0, as_array_1.asArray)(type));
}
/**
 * Type predicate expression with NOT
 * @group Expressions
 * @see {@link https://neo4j.com/docs/cypher-manual/current/values-and-types/type-predicate/#type-predicate-not | Cypher Documentation}
 * @example
 * ```cypher
 * val IS NOT :: INTEGER
 * ```
 */
function isNotType(expr, type) {
    return new IsType(expr, (0, as_array_1.asArray)(type), true);
}
/**
 * @group Expressions
 */
class ListType {
    /** @internal */
    constructor(type) {
        this._notNull = false;
        this.types = type;
    }
    notNull() {
        this._notNull = true;
        return this;
    }
    /** @internal */
    getCypher(env) {
        // Note that all types must be nullable or non nullable
        const notNullStr = this._notNull ? " NOT NULL" : "";
        const typesStr = this.types
            .map((type) => {
            const typeStr = compileType(type, env);
            return `${typeStr}${notNullStr}`;
        })
            .join(" | ");
        return `LIST<${typesStr}>`;
    }
}
exports.ListType = ListType;
/**
 * @group Expressions
 */
class IsType extends CypherASTNode_1.CypherASTNode {
    /** @internal */
    constructor(expr, type, not = false) {
        super();
        this._notNull = false;
        this.expr = expr;
        this.types = type;
        this.not = not;
    }
    notNull() {
        this._notNull = true;
        return this;
    }
    /** @internal */
    getCypher(env) {
        const exprCypher = this.expr.getCypher(env);
        const isStr = this.not ? "IS NOT" : "IS";
        // Note that all types must be nullable or non nullable
        const notNullStr = this._notNull ? " NOT NULL" : "";
        const typesStr = this.types
            .map((type) => {
            const typeStr = compileType(type, env);
            return `${typeStr}${notNullStr}`;
        })
            .join(" | ");
        return `${exprCypher} ${isStr} :: ${typesStr}`;
    }
}
exports.IsType = IsType;
function compileType(type, env) {
    if (type instanceof ListType) {
        return type.getCypher(env);
    }
    else {
        return type;
    }
}
